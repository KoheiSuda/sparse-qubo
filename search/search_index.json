{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"sparse-qubo","text":"<p>Sparse QUBO formulation for efficient embedding on hardware.</p> <p><code>sparse-qubo</code> is a Python library that provides sparse QUBO (Quadratic Unconstrained Binary Optimization) formulations specifically for N-hot equality and inequality constraints. Constraint QUBOs are built from switching networks: each network is a list of Switch elements (left/right variable sets and constants), and the library converts them into QUBOs optimized for embedding on quantum annealing hardware (e.g. D-Wave) or other solvers.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multiple constraint types: One-hot, equal-to, less-equal, greater-equal, and clamp</li> <li>Switching networks: Constraint formulations are implemented as switching networks (each network is a list of Switch objects), which yield small quadratic terms</li> <li>Multiple network architectures:</li> <li>Benes network</li> <li>Bitonic sort network</li> <li>Bubble sort network</li> <li>Clos network (max degree and minimum edge variants)</li> <li>Divide-and-conquer network</li> <li>Odd-even merge sort network</li> <li>Backends: D-Wave (<code>dimod.BQM</code>) and Fixstars Amplify (<code>amplify.Model</code>)</li> <li>Examples: Repository includes example problems (shift scheduling, TSP) with notebooks and benchmarks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install sparse-qubo\n</code></pre> <p>Or using <code>uv</code>:</p> <pre><code>uv add sparse-qubo\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#d-wave-dimod","title":"D-Wave (dimod)","text":"<p>Create a one-hot constraint using the divide-and-conquer network:</p> <pre><code>import dimod\nimport sparse_qubo\n\nvariables = dimod.variables.Variables([\"x0\", \"x1\", \"x2\", \"x3\"])\n\n# One-hot constraint\nbqm = sparse_qubo.create_constraint_dwave(\n    variables,\n    sparse_qubo.ConstraintType.ONE_HOT,\n    sparse_qubo.NetworkType.DIVIDE_AND_CONQUER,\n)\n</code></pre>"},{"location":"#constraint-types-and-network-types","title":"Constraint types and network types","text":"<pre><code># Equal-to: sum of variables equals 2\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.EQUAL_TO, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=2)\n\n# Less-equal: sum &lt;= 3\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.LESS_EQUAL, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=3)\n\n# Naive formulation (single switch; no additional variables, denser quadratic terms)\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.ONE_HOT, sparse_qubo.NetworkType.NAIVE)\n\n# Other networks (e.g. bubble sort network)\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.ONE_HOT, sparse_qubo.NetworkType.BUBBLE_SORT)\n</code></pre>"},{"location":"#repository-examples","title":"Repository examples","text":"<p>The <code>examples/</code> directory contains full problem setups:</p> <ul> <li>Shift scheduling (<code>examples/shift_scheduling/</code>): Demo notebook, problem builder (<code>create_scheduling_problem_bqm</code> using <code>sparse_qubo.create_constraint_dwave</code>), and benchmarks comparing <code>NetworkType.NAIVE</code> vs <code>NetworkType.DIVIDE_AND_CONQUER</code> on D-Wave</li> <li>TSP (<code>examples/tsp/</code>): Problem builder and benchmarks for traveling salesman formulations</li> </ul> <p>See Examples for details and inline code samples.</p>"},{"location":"#reference","title":"Reference","text":"<p>This library implements the sparse QUBO formulation described in:</p> <p>Kohei Suda, Soshun Naito, Yoshihiko Hasegawa. Sparse QUBO Formulation for Efficient Embedding via Network-Based Decomposition of Equality and Inequality Constraints. arXiv:2601.18108, 2026. https://arxiv.org/abs/2601.18108</p> <p>The paper provides a comprehensive description of the network-based constraint decomposition and the divide-and-conquer algorithm utilized in this library. Furthermore, it discusses the effectiveness of the method through experiments performed on D-Wave hardware.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started \u2014 Concepts, constraint and network types, low-level API</li> <li>Examples \u2014 Inline examples and repository example overview</li> <li>Usage \u2014 Constraint prefix counter and variable naming</li> <li>API Reference \u2014 Module and class reference</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome. See CONTRIBUTING.md for guidelines.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms specified in the LICENSE file.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub: https://github.com/KoheiSuda/sparse-qubo/</li> <li>Documentation: https://KoheiSuda.github.io/sparse-qubo/</li> <li>PyPI: https://pypi.org/project/sparse-qubo/</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page gives an overview of the repository examples in the <code>examples/</code> directory.</p>"},{"location":"examples/#repository-examples","title":"Repository examples","text":"<p>The repository includes full problem setups that show how to combine constraints with objectives and compare network types.</p>"},{"location":"examples/#shift-scheduling-examplesshift_scheduling","title":"Shift scheduling (<code>examples/shift_scheduling/</code>)","text":"<ul> <li>Problem: Assign workers to shifts per day with row/column sums and incompatible worker pairs.</li> <li>Files:</li> <li><code>problem.py</code>: <code>create_scheduling_problem_bqm(network_type, ...)</code> builds a BQM using <code>sparse_qubo.create_constraint_dwave</code> for row and column \u201cexactly k selected\u201d constraints, plus incompatible-pair penalties and a cost matrix.</li> <li><code>demo.ipynb</code>: Jupyter notebook that compares NAIVE vs DIVIDE_AND_CONQUER on D-Wave (variables, interactions, embedding qubits, chain strength, chain break rate, energy).</li> <li><code>benchmark.py</code>: Script to run multiple trials and save/analyze results.</li> <li>Usage: Run the notebook or benchmark from the project root (or add the root to <code>sys.path</code>). See the notebook for parameter and solver setup.</li> </ul>"},{"location":"examples/#tsp-examplestsp","title":"TSP (<code>examples/tsp/</code>)","text":"<ul> <li>Problem: Traveling salesman on a graph (one visit per city, one city per step).</li> <li>Files:</li> <li><code>problem.py</code>: <code>create_tsp_problem_bqm(network_type, dist_matrix)</code> builds a BQM with row/column one-hot constraints via <code>sparse_qubo.create_constraint_dwave</code> and distance-based quadratic objective.</li> <li><code>benchmark.py</code>: Benchmark script for TSP formulations.</li> <li>Usage: Import from <code>examples.tsp.problem</code> after adding the project root to <code>sys.path</code>, or run the benchmark script.</li> </ul> <p>Both examples illustrate the typical pattern: build constraint BQMs per row/column with <code>sparse_qubo.create_constraint_dwave</code>, add objective terms, and optionally compare NAIVE vs DIVIDE_AND_CONQUER (or other network types).</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide introduces core concepts and basic usage of <code>sparse-qubo</code>.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install sparse-qubo\n</code></pre> <p>Or with <code>uv</code>:</p> <pre><code>uv add sparse-qubo\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#qubo-formulation","title":"QUBO formulation","text":"<p>QUBO (Quadratic Unconstrained Binary Optimization) is a formulation used in quantum annealing and related methods. A QUBO is:</p> \\[ \\min \\sum_{i} a_i x_i + \\sum_{i&lt;j} b_{ij} x_i x_j \\] <p>with binary variables \\(x_i \\in \\{0, 1\\}\\).</p>"},{"location":"getting-started/#switching-networks-and-switch","title":"Switching networks and Switch","text":"<p>Constraint QUBOs in this library are built from switching networks. A switching network is a list of Switch objects. Each Switch has:</p> <ul> <li>Left and right variable sets: Two disjoint sets of binary variable names and optional integer constants. The constraint is encoded by requiring that the sum on the left equals the sum on the right (up to constants) for each Switch.</li> <li>QUBO conversion: The function <code>Switch.to_qubo(switches)</code> turns a list of Switch elements into a single QUBO (variables, linear, quadratic, constant).</li> </ul> <p>Different network types (e.g. divide-and-conquer, Benes, bubble sort) produce different sequences of Switch elements and thus different variable counts and sparsity. The NAIVE network type does not use switching networks; it encodes the constraint as a single squared term in the usual way (no additional variables, denser quadratic terms).</p>"},{"location":"getting-started/#constraint-types","title":"Constraint types","text":"<p>Supported constraint types:</p> Type Description ONE_HOT Exactly one variable is 1 EQUAL_TO Sum of variables equals a value (<code>c1</code>) LESS_EQUAL Sum of variables \u2264 value (<code>c1</code>) GREATER_EQUAL Sum of variables \u2265 value (<code>c1</code>) CLAMP Sum of variables in [<code>c1</code>, <code>c2</code>]"},{"location":"getting-started/#network-types","title":"Network types","text":"Network Notes DIVIDE_AND_CONQUER General-purpose; good default BUBBLE_SORT Simple sorting network BITONIC_SORT / BENES / ODDEVEN_MERGE_SORT Require power-of-2 variable size and automatically add auxiliary variables CLOS_NETWORK_MAX_DEGREE Tune max degree (see network module) CLOS_NETWORK_MIN_EDGE Minimize edge count NAIVE No switching network; single squared term"},{"location":"getting-started/#basic-usage","title":"Basic usage","text":""},{"location":"getting-started/#creating-constraints-d-wave-dimod","title":"Creating constraints (D-Wave / dimod)","text":"<p>Use <code>sparse_qubo.create_constraint_dwave</code> to get a <code>dimod.BinaryQuadraticModel</code>:</p> <pre><code>import dimod\nimport sparse_qubo\n\nvariables = dimod.variables.Variables([\"x0\", \"x1\", \"x2\", \"x3\"])\n\n# One-hot\nbqm = sparse_qubo.create_constraint_dwave(\n    variables,\n    sparse_qubo.ConstraintType.ONE_HOT,\n    sparse_qubo.NetworkType.DIVIDE_AND_CONQUER,\n)\n</code></pre>"},{"location":"getting-started/#constraint-types-d-wave","title":"Constraint types (D-Wave)","text":"<pre><code># Equal-to: sum = 2\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.EQUAL_TO, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=2)\n\n# Less-equal: sum &lt;= 3\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.LESS_EQUAL, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=3)\n\n# Greater-equal: sum &gt;= 1\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.GREATER_EQUAL, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=1)\n\n# Clamp: 1 &lt;= sum &lt;= 3\nbqm = sparse_qubo.create_constraint_dwave(variables, sparse_qubo.ConstraintType.CLAMP, sparse_qubo.NetworkType.DIVIDE_AND_CONQUER, c1=1, c2=3)\n</code></pre>"},{"location":"getting-started/#choosing-a-network-type","title":"Choosing a network type","text":"<ul> <li>DIVIDE_AND_CONQUER: Default for most use cases; works for any size and constraint type.</li> <li>BUBBLE_SORT: Simple; may use more variables.</li> <li>BITONIC_SORT, BENES, ODDEVEN_MERGE_SORT: Only for power-of-2 variable count; can reduce edges.</li> <li>CLOS_NETWORK_MAX_DEGREE / CLOS_NETWORK_MIN_EDGE: When you need to tune degree or edge count (see API and examples).</li> <li>NAIVE: Single linear equality; fewer variables, denser QUBO.</li> </ul>"},{"location":"getting-started/#optional-parameters","title":"Optional parameters","text":"<ul> <li>threshold: For recursive networks (e.g. DIVIDE_AND_CONQUER), stop recursion when group size \u2264 <code>threshold</code>.</li> <li>var_prefix: In the low-level API, optional prefix for auxiliary variables to avoid name collisions when merging QUBOs. See Usage.</li> </ul>"},{"location":"getting-started/#low-level-api","title":"Low-level API","text":"<p>For direct access to QUBO or switching networks:</p> <pre><code>from sparse_qubo.core.constraint import get_constraint_qubo, ConstraintType\nfrom sparse_qubo.core.network import NetworkType\n\n# Get QUBO (variables, linear, quadratic, constant)\nqubo = get_constraint_qubo(\n    [\"x0\", \"x1\", \"x2\", \"x3\"],\n    ConstraintType.ONE_HOT,\n    NetworkType.DIVIDE_AND_CONQUER,\n)\n\nprint(qubo.variables, qubo.linear, qubo.quadratic, qubo.constant)\n</code></pre> <p>To work with Switch lists (e.g. for custom analysis or visualization):</p> <pre><code>from sparse_qubo.core.constraint import get_initial_nodes\nfrom sparse_qubo.core.network import NetworkType\nfrom sparse_qubo.networks.divide_and_conquer_network import DivideAndConquerNetwork\n\nvariables = [f\"x{i}\" for i in range(4)]\nleft_nodes, right_nodes = get_initial_nodes(variables, ConstraintType.ONE_HOT)\nswitches = DivideAndConquerNetwork.generate_network(left_nodes, right_nodes)\n# switches is list[Switch]; use Switch.to_qubo(switches) to get QUBO\n</code></pre>"},{"location":"getting-started/#fixstars-amplify","title":"Fixstars Amplify","text":"<p>For Amplify, use <code>sparse_qubo.create_constraint_amplify</code>. It accepts a list of <code>amplify.Variable</code> and returns an <code>amplify.Model</code>:</p> <pre><code>import amplify\nimport sparse_qubo\n\nvariables = [amplify.Variable(f\"x{i}\") for i in range(4)]\nmodel = sparse_qubo.create_constraint_amplify(\n    variables,\n    sparse_qubo.ConstraintType.ONE_HOT,\n    sparse_qubo.NetworkType.DIVIDE_AND_CONQUER,\n)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Examples \u2014 Inline examples and repository example overview</li> <li>Usage \u2014 Constraint prefix counter and variable naming</li> <li>API Reference \u2014 Full module and class reference</li> </ul>"},{"location":"modules/","title":"API Reference","text":"<p>This page lists the main modules and classes of <code>sparse-qubo</code>.</p> <p>Public API (top-level package): Use <code>sparse_qubo.create_constraint_dwave</code> for D-Wave/dimod BQMs and <code>sparse_qubo.create_constraint_amplify</code> for Fixstars Amplify models. Constraint and network types are <code>sparse_qubo.ConstraintType</code> and <code>sparse_qubo.NetworkType</code>. The sections below document the implementation modules.</p>"},{"location":"modules/#core-modules","title":"Core modules","text":""},{"location":"modules/#sparse_qubo.core.constraint","title":"<code>sparse_qubo.core.constraint</code>","text":"<p>Constraint types and QUBO construction for equality/inequality constraints.</p> <p>This module provides ConstraintType, get_initial_nodes, and get_constraint_qubo to build QUBOs from switching networks for use with D-Wave or Amplify.</p>"},{"location":"modules/#sparse_qubo.core.constraint.ConstraintType","title":"<code>ConstraintType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Type of linear constraint on binary variables (sum of variables).</p> Source code in <code>src/sparse_qubo/core/constraint.py</code> <pre><code>class ConstraintType(StrEnum):\n    \"\"\"Type of linear constraint on binary variables (sum of variables).\"\"\"\n\n    ONE_HOT = \"one_hot\"  # Exactly one variable is 1\n    EQUAL_TO = \"equal_to\"  # Sum equals c1\n    LESS_EQUAL = \"less_equal\"  # Sum &lt;= c1\n    GREATER_EQUAL = \"greater_equal\"  # Sum &gt;= c1\n    CLAMP = \"clamp\"  # c1 &lt;= sum &lt;= c2\n</code></pre>"},{"location":"modules/#sparse_qubo.core.constraint.get_constraint_qubo","title":"<code>get_constraint_qubo(variables, constraint_type, network_type=NetworkType.DIVIDE_AND_CONQUER, c1=None, c2=None, threshold=None, reverse=False, var_prefix=None)</code>","text":"<p>Build a QUBO for the given constraint.</p> <p>Auxiliary variable prefixes</p> <p>When <code>var_prefix</code> is <code>None</code> (the default), a unique prefix is assigned internally (<code>C0</code>, <code>C1</code>, ...) so that merging multiple constraint QUBOs into one BQM avoids name collisions. The counter increments on each call and is not reset automatically; it resets only on process start or when calling :func:<code>reset_constraint_prefix_counter</code>. See the Usage section (Constraint prefix counter) in the documentation for details.</p> Source code in <code>src/sparse_qubo/core/constraint.py</code> <pre><code>def get_constraint_qubo(\n    variables: list[str],\n    constraint_type: ConstraintType,\n    network_type: NetworkType = NetworkType.DIVIDE_AND_CONQUER,\n    c1: int | None = None,\n    c2: int | None = None,\n    threshold: int | None = None,\n    reverse: bool = False,\n    var_prefix: str | None = None,\n) -&gt; QUBO:\n    \"\"\"Build a QUBO for the given constraint.\n\n    **Auxiliary variable prefixes**\n\n    When ``var_prefix`` is ``None`` (the default), a unique prefix is assigned\n    internally (``C0``, ``C1``, ...) so that merging multiple constraint QUBOs\n    into one BQM avoids name collisions. The counter increments on each call\n    and is **not** reset automatically; it resets only on process start or when\n    calling :func:`reset_constraint_prefix_counter`. See the Usage section\n    (Constraint prefix counter) in the documentation for details.\n    \"\"\"\n    global _constraint_prefix_counter\n    if var_prefix is None:\n        var_prefix = f\"C{_constraint_prefix_counter!s}\"\n        _constraint_prefix_counter += 1\n\n    match network_type:\n        case NetworkType.BENES:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2, exponentiation=True)\n            switches = BenesNetwork.generate_network(left_nodes, right_nodes, threshold=threshold, reverse=reverse)\n        case NetworkType.BITONIC_SORT:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2, exponentiation=True)\n            switches = BitonicSortNetwork.generate_network(\n                left_nodes, right_nodes, threshold=threshold, reverse=reverse\n            )\n        case NetworkType.BUBBLE_SORT:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2)\n            switches = BubbleSortNetwork.generate_network(left_nodes, right_nodes, threshold=threshold, reverse=reverse)\n        case NetworkType.CLOS_NETWORK_MAX_DEGREE:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2)\n            switches = ClosNetworkWithMaxDegree.generate_network(\n                left_nodes, right_nodes, threshold=threshold, reverse=reverse\n            )\n        case NetworkType.CLOS_NETWORK_MIN_EDGE:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2)\n            switches = ClosNetworkMinimumEdge.generate_network(\n                left_nodes, right_nodes, threshold=threshold, reverse=reverse\n            )\n        case NetworkType.DIVIDE_AND_CONQUER:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2)\n            switches = DivideAndConquerNetwork.generate_network(\n                left_nodes, right_nodes, threshold=threshold, reverse=reverse\n            )\n        case NetworkType.ODDEVEN_MERGE_SORT:\n            left_nodes, right_nodes = get_initial_nodes(variables, constraint_type, c1, c2, exponentiation=True)\n            switches = OddEvenMergeSortNetwork.generate_network(\n                left_nodes, right_nodes, threshold=threshold, reverse=reverse\n            )\n        case _:\n            raise NotImplementedError\n    qubo = Switch.to_qubo(switches)\n    qubo = _prefix_auxiliary_variables(qubo, set(variables), var_prefix)\n    return qubo\n</code></pre>"},{"location":"modules/#sparse_qubo.core.constraint.get_initial_nodes","title":"<code>get_initial_nodes(variables, constraint_type, c1=None, c2=None, exponentiation=False)</code>","text":"<p>Build left and right VariableNode lists for a switching network from variable names and constraint type.</p> <p>Used by get_constraint_qubo and by network implementations. If exponentiation is True, the right side is padded to a power-of-2 size (for Benes, Bitonic, OddEvenMergeSort).</p> Source code in <code>src/sparse_qubo/core/constraint.py</code> <pre><code>def get_initial_nodes(\n    variables: list[str],\n    constraint_type: ConstraintType,\n    c1: int | None = None,\n    c2: int | None = None,\n    exponentiation: bool = False,\n) -&gt; tuple[list[VariableNode], list[VariableNode]]:\n    \"\"\"Build left and right VariableNode lists for a switching network from variable names and constraint type.\n\n    Used by get_constraint_qubo and by network implementations. If exponentiation is True,\n    the right side is padded to a power-of-2 size (for Benes, Bitonic, OddEvenMergeSort).\n    \"\"\"\n    original_size = len(variables)\n    target_size = original_size\n    if exponentiation and original_size &gt; 0:\n        target_size = 1 &lt;&lt; (original_size - 1).bit_length()\n    pad_len = target_size - original_size\n\n    left_pad_attrs = [NodeAttribute.ALWAYS_ZERO] * pad_len\n    left_var_attrs = [NodeAttribute.ZERO_OR_ONE] * original_size\n\n    def get_original_right_attr(i: int) -&gt; NodeAttribute:\n        match constraint_type:\n            case ConstraintType.ONE_HOT:\n                return NodeAttribute.ALWAYS_ZERO if i &lt; original_size - 1 else NodeAttribute.ALWAYS_ONE\n            case ConstraintType.EQUAL_TO:\n                if c1 is None or not (0 &lt;= c1 &lt;= original_size):\n                    raise ValueError(f\"c1 must be between 0 and {original_size}\")\n                return NodeAttribute.ALWAYS_ZERO if i &lt; original_size - c1 else NodeAttribute.ALWAYS_ONE\n            case ConstraintType.LESS_EQUAL:\n                if c1 is None or not (0 &lt; c1 &lt;= original_size):\n                    raise ValueError(f\"c1 must be between 0 and {original_size}\")\n                return NodeAttribute.ALWAYS_ZERO if i &lt; original_size - c1 else NodeAttribute.NOT_CARE\n            case ConstraintType.GREATER_EQUAL:\n                if c1 is None or not (0 &lt;= c1 &lt; original_size):\n                    raise ValueError(f\"c1 must be between 0 and {original_size}\")\n                return NodeAttribute.NOT_CARE if i &lt; original_size - c1 else NodeAttribute.ALWAYS_ONE\n            case ConstraintType.CLAMP:\n                if c1 is None or c2 is None or not (0 &lt;= c1 &lt;= c2 &lt;= original_size):\n                    raise ValueError(f\"c1 and c2 must be valid range (0 &lt;= c1 &lt;= c2 &lt;= {original_size})\")\n                if i &lt; original_size - c2:\n                    return NodeAttribute.ALWAYS_ZERO\n                elif i &lt; original_size - c1:\n                    return NodeAttribute.NOT_CARE\n                else:\n                    return NodeAttribute.ALWAYS_ONE\n            case _:\n                raise NotImplementedError(f\"Constraint type {constraint_type} is not supported\")\n\n    original_right_attrs = [get_original_right_attr(i) for i in range(original_size)]\n    right_attrs = [NodeAttribute.ALWAYS_ZERO] * pad_len + original_right_attrs\n\n    left_nodes = [VariableNode(name=f\"L{i}\", attribute=attr) for i, attr in enumerate(left_pad_attrs)] + [\n        VariableNode(name=str(v), attribute=attr) for v, attr in zip(variables, left_var_attrs, strict=True)\n    ]\n    right_nodes = [VariableNode(name=f\"R{i}\", attribute=attr) for i, attr in enumerate(right_attrs)]\n\n    return left_nodes, right_nodes\n</code></pre>"},{"location":"modules/#sparse_qubo.core.constraint.reset_constraint_prefix_counter","title":"<code>reset_constraint_prefix_counter()</code>","text":"<p>Reset the internal constraint prefix counter.</p> <p>The prefix counter is not reset automatically. It is reset only when:</p> <ol> <li>Process start: Restarting Python (e.g. re-running a script or    restarting a Jupyter kernel) reloads the module and sets the counter to 0.</li> <li>Explicit call: Calling this function sets the counter back to 0.</li> </ol> <p>Call this when you want the next constraint to use prefix <code>C0</code> again (e.g. when starting to build a new model in the same process). Mainly useful for testing or reproducible variable names.</p> Source code in <code>src/sparse_qubo/core/constraint.py</code> <pre><code>def reset_constraint_prefix_counter() -&gt; None:\n    \"\"\"Reset the internal constraint prefix counter.\n\n    The prefix counter is **not** reset automatically. It is reset only when:\n\n    1. **Process start**: Restarting Python (e.g. re-running a script or\n       restarting a Jupyter kernel) reloads the module and sets the counter to 0.\n    2. **Explicit call**: Calling this function sets the counter back to 0.\n\n    Call this when you want the next constraint to use prefix ``C0`` again\n    (e.g. when starting to build a new model in the same process). Mainly useful\n    for testing or reproducible variable names.\n    \"\"\"\n    global _constraint_prefix_counter\n    _constraint_prefix_counter = 0\n</code></pre>"},{"location":"modules/#sparse_qubo.core.network","title":"<code>sparse_qubo.core.network</code>","text":"<p>Switching network types and base class for network implementations.</p> <p>NetworkType enumerates available formulations. ISwitchingNetwork is the abstract base for networks that produce a list of Switch elements.</p>"},{"location":"modules/#sparse_qubo.core.network.ISwitchingNetwork","title":"<code>ISwitchingNetwork</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base for switching networks that produce a list of Switch elements.</p> Source code in <code>src/sparse_qubo/core/network.py</code> <pre><code>class ISwitchingNetwork(ABC):\n    \"\"\"Abstract base for switching networks that produce a list of Switch elements.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Return the raw list of Switch elements for the given left/right nodes.\"\"\"\n        pass\n\n    @classmethod\n    def generate_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Build the switching network, simplifying switches when nodes are fixed (ALWAYS_ZERO/ALWAYS_ONE).\"\"\"\n        network: list[Switch] = cls._generate_original_network(left_nodes, right_nodes, threshold, reverse)\n\n        # Place switch while managing the set of rightmost nodes\n        current_nodes: set[str] = {node.name for node in right_nodes}\n        name_to_attribute: dict[str, NodeAttribute] = {node.name: node.attribute for node in right_nodes}\n        result_network: list[Switch] = []\n        for switch in network[::-1]:  # Look from the right\n            # Raise an error if there are no nodes to connect\n            if not switch.right_nodes.issubset(current_nodes):\n                raise ValueError(f\"Invalid network: {switch.right_nodes} is not subset of {current_nodes}\")\n            current_nodes.difference_update(switch.right_nodes)\n\n            # Raise an error if nodes that should be newly generated already exist\n            if not switch.left_nodes.isdisjoint(current_nodes):\n                raise ValueError(f\"Invalid network: {switch.left_nodes} is not disjoint with {current_nodes}\")\n            current_nodes.update(switch.left_nodes)\n\n            # Calculate the range of possible values for left and right\n            num_left_variables: int = len(switch.left_nodes)\n            right_sum_min: int = (\n                len([node for node in switch.right_nodes if name_to_attribute[node] == NodeAttribute.ALWAYS_ONE])\n                + switch.right_constant\n                - switch.left_constant\n            )\n            right_sum_max: int = (\n                len([node for node in switch.right_nodes if name_to_attribute[node] != NodeAttribute.ALWAYS_ZERO])\n                + switch.right_constant\n                - switch.left_constant\n            )\n\n            # Raise an error if the range is not achievable\n            if not (right_sum_max &gt;= 0 and right_sum_min &lt;= num_left_variables):\n                raise ValueError(\n                    f\"Invalid network: right_sum_max = {right_sum_max} &lt; 0 or right_sum_min = {right_sum_min} &gt; {num_left_variables}\"\n                )\n\n            # When the right side's lower bound matches the left side's upper bound, all left nodes must be 1\n            if right_sum_min == num_left_variables:\n                for node in switch.left_nodes:\n                    name_to_attribute[node] = NodeAttribute.ALWAYS_ONE\n                    result_network.append(\n                        Switch(\n                            left_nodes=frozenset([node]),\n                            right_nodes=frozenset(),\n                            left_constant=0,\n                            right_constant=1,\n                        )\n                    )\n            # When the right side's upper bound is 0, all left nodes must be 0\n            elif right_sum_max == 0:\n                for node in switch.left_nodes:\n                    name_to_attribute[node] = NodeAttribute.ALWAYS_ZERO\n                    result_network.append(\n                        Switch(\n                            left_nodes=frozenset([node]),\n                            right_nodes=frozenset(),\n                            left_constant=0,\n                            right_constant=0,\n                        )\n                    )\n            # When all right nodes are NOT_CARE and there are no restrictions on the left side's possible value range, all left nodes become NOT_CARE\n            elif (\n                all(name_to_attribute[node] == NodeAttribute.NOT_CARE for node in switch.right_nodes)\n                and right_sum_min &lt;= 0\n                and right_sum_max &gt;= num_left_variables\n            ):\n                for node in switch.left_nodes:\n                    name_to_attribute[node] = NodeAttribute.NOT_CARE\n            # Otherwise, left nodes become normal nodes\n            else:\n                for node in switch.left_nodes:\n                    name_to_attribute[node] = NodeAttribute.ZERO_OR_ONE\n                # Add network with constant nodes omitted\n                result_network.append(\n                    Switch(\n                        left_nodes=frozenset(switch.left_nodes),\n                        right_nodes=frozenset([\n                            node\n                            for node in switch.right_nodes\n                            if name_to_attribute[node] != NodeAttribute.ALWAYS_ONE\n                            and name_to_attribute[node] != NodeAttribute.ALWAYS_ZERO\n                        ]),\n                        left_constant=switch.left_constant,\n                        right_constant=switch.right_constant\n                        + len([\n                            node for node in switch.right_nodes if name_to_attribute[node] == NodeAttribute.ALWAYS_ONE\n                        ]),\n                    )\n                )\n        if reverse:\n            return result_network[::-1]\n        else:\n            return result_network\n</code></pre>"},{"location":"modules/#sparse_qubo.core.network.ISwitchingNetwork.generate_network","title":"<code>generate_network(left_nodes, right_nodes, threshold=None, reverse=False)</code>  <code>classmethod</code>","text":"<p>Build the switching network, simplifying switches when nodes are fixed (ALWAYS_ZERO/ALWAYS_ONE).</p> Source code in <code>src/sparse_qubo/core/network.py</code> <pre><code>@classmethod\ndef generate_network(\n    cls,\n    left_nodes: list[VariableNode],\n    right_nodes: list[VariableNode],\n    threshold: int | None = None,\n    reverse: bool = False,\n) -&gt; list[Switch]:\n    \"\"\"Build the switching network, simplifying switches when nodes are fixed (ALWAYS_ZERO/ALWAYS_ONE).\"\"\"\n    network: list[Switch] = cls._generate_original_network(left_nodes, right_nodes, threshold, reverse)\n\n    # Place switch while managing the set of rightmost nodes\n    current_nodes: set[str] = {node.name for node in right_nodes}\n    name_to_attribute: dict[str, NodeAttribute] = {node.name: node.attribute for node in right_nodes}\n    result_network: list[Switch] = []\n    for switch in network[::-1]:  # Look from the right\n        # Raise an error if there are no nodes to connect\n        if not switch.right_nodes.issubset(current_nodes):\n            raise ValueError(f\"Invalid network: {switch.right_nodes} is not subset of {current_nodes}\")\n        current_nodes.difference_update(switch.right_nodes)\n\n        # Raise an error if nodes that should be newly generated already exist\n        if not switch.left_nodes.isdisjoint(current_nodes):\n            raise ValueError(f\"Invalid network: {switch.left_nodes} is not disjoint with {current_nodes}\")\n        current_nodes.update(switch.left_nodes)\n\n        # Calculate the range of possible values for left and right\n        num_left_variables: int = len(switch.left_nodes)\n        right_sum_min: int = (\n            len([node for node in switch.right_nodes if name_to_attribute[node] == NodeAttribute.ALWAYS_ONE])\n            + switch.right_constant\n            - switch.left_constant\n        )\n        right_sum_max: int = (\n            len([node for node in switch.right_nodes if name_to_attribute[node] != NodeAttribute.ALWAYS_ZERO])\n            + switch.right_constant\n            - switch.left_constant\n        )\n\n        # Raise an error if the range is not achievable\n        if not (right_sum_max &gt;= 0 and right_sum_min &lt;= num_left_variables):\n            raise ValueError(\n                f\"Invalid network: right_sum_max = {right_sum_max} &lt; 0 or right_sum_min = {right_sum_min} &gt; {num_left_variables}\"\n            )\n\n        # When the right side's lower bound matches the left side's upper bound, all left nodes must be 1\n        if right_sum_min == num_left_variables:\n            for node in switch.left_nodes:\n                name_to_attribute[node] = NodeAttribute.ALWAYS_ONE\n                result_network.append(\n                    Switch(\n                        left_nodes=frozenset([node]),\n                        right_nodes=frozenset(),\n                        left_constant=0,\n                        right_constant=1,\n                    )\n                )\n        # When the right side's upper bound is 0, all left nodes must be 0\n        elif right_sum_max == 0:\n            for node in switch.left_nodes:\n                name_to_attribute[node] = NodeAttribute.ALWAYS_ZERO\n                result_network.append(\n                    Switch(\n                        left_nodes=frozenset([node]),\n                        right_nodes=frozenset(),\n                        left_constant=0,\n                        right_constant=0,\n                    )\n                )\n        # When all right nodes are NOT_CARE and there are no restrictions on the left side's possible value range, all left nodes become NOT_CARE\n        elif (\n            all(name_to_attribute[node] == NodeAttribute.NOT_CARE for node in switch.right_nodes)\n            and right_sum_min &lt;= 0\n            and right_sum_max &gt;= num_left_variables\n        ):\n            for node in switch.left_nodes:\n                name_to_attribute[node] = NodeAttribute.NOT_CARE\n        # Otherwise, left nodes become normal nodes\n        else:\n            for node in switch.left_nodes:\n                name_to_attribute[node] = NodeAttribute.ZERO_OR_ONE\n            # Add network with constant nodes omitted\n            result_network.append(\n                Switch(\n                    left_nodes=frozenset(switch.left_nodes),\n                    right_nodes=frozenset([\n                        node\n                        for node in switch.right_nodes\n                        if name_to_attribute[node] != NodeAttribute.ALWAYS_ONE\n                        and name_to_attribute[node] != NodeAttribute.ALWAYS_ZERO\n                    ]),\n                    left_constant=switch.left_constant,\n                    right_constant=switch.right_constant\n                    + len([\n                        node for node in switch.right_nodes if name_to_attribute[node] == NodeAttribute.ALWAYS_ONE\n                    ]),\n                )\n            )\n    if reverse:\n        return result_network[::-1]\n    else:\n        return result_network\n</code></pre>"},{"location":"modules/#sparse_qubo.core.network.NetworkType","title":"<code>NetworkType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Identifier for each switching network (or naive) formulation.</p> Source code in <code>src/sparse_qubo/core/network.py</code> <pre><code>class NetworkType(StrEnum):\n    \"\"\"Identifier for each switching network (or naive) formulation.\"\"\"\n\n    NAIVE = \"naive\"\n    BENES = \"benes\"\n    BITONIC_SORT = \"bitonic_sort\"\n    BUBBLE_SORT = \"bubble_sort\"\n    CLOS_NETWORK_MAX_DEGREE = \"clos_network_max_degree\"\n    CLOS_NETWORK_MIN_EDGE = \"clos_network_min_edge\"\n    DIVIDE_AND_CONQUER = \"divide_and_conquer\"\n    ODDEVEN_MERGE_SORT = \"oddeven_merge_sort\"\n</code></pre>"},{"location":"modules/#sparse_qubo.core.node","title":"<code>sparse_qubo.core.node</code>","text":"<p>Nodes and attributes for switching network construction.</p> <p>VariableNode represents a binary variable with an optional NodeAttribute (ALWAYS_ZERO, ALWAYS_ONE, NOT_CARE, or ZERO_OR_ONE).</p>"},{"location":"modules/#sparse_qubo.core.node.NodeAttribute","title":"<code>NodeAttribute</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Attribute of a binary variable in the switching network.</p> Source code in <code>src/sparse_qubo/core/node.py</code> <pre><code>class NodeAttribute(Enum):\n    \"\"\"Attribute of a binary variable in the switching network.\"\"\"\n\n    ZERO_OR_ONE = \"ZERO_OR_ONE\"  # General case\n    ALWAYS_ZERO = \"ALWAYS_ZERO\"  # Fixed to 0\n    ALWAYS_ONE = \"ALWAYS_ONE\"  # Fixed to 1\n    NOT_CARE = \"NOT_CARE\"  # Unconstrained\n</code></pre>"},{"location":"modules/#sparse_qubo.core.node.VariableNode","title":"<code>VariableNode</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A binary variable with a name and an attribute.</p> Source code in <code>src/sparse_qubo/core/node.py</code> <pre><code>class VariableNode(BaseModel):\n    \"\"\"A binary variable with a name and an attribute.\"\"\"\n\n    name: str = Field(description=\"Name of the binary variable\", frozen=True)\n    attribute: NodeAttribute = Field(default=NodeAttribute.ZERO_OR_ONE, description=\"Attribute of the binary variable\")\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch","title":"<code>sparse_qubo.core.switch</code>","text":"<p>Switch elements and QUBO conversion for switching networks.</p> <p>A Switch encodes a constraint that the sum of left variables plus left_constant equals the sum of right variables plus right_constant. Switch.to_qubo converts a list of Switch elements into a single QUBO (variables, linear, quadratic, constant).</p>"},{"location":"modules/#sparse_qubo.core.switch.QUBO","title":"<code>QUBO</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>QUBO representation: variables, linear and quadratic coefficients, and constant.</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>class QUBO(BaseModel):\n    \"\"\"QUBO representation: variables, linear and quadratic coefficients, and constant.\"\"\"\n\n    variables: frozenset[str] = Field(description=\"Set of binary variables\")\n    quadratic: dict[frozenset[str], float] = Field(description=\"Coefficients between binary variables\")\n    linear: dict[str, float] = Field(description=\"Coefficients of binary variables\")\n    constant: float = Field(default=0, description=\"Constant term\")\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch","title":"<code>Switch</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Single switch: left and right variable sets and optional integer constants.</p> <p>The constraint is: sum(left_nodes) + left_constant == sum(right_nodes) + right_constant.</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>class Switch(BaseModel):\n    \"\"\"Single switch: left and right variable sets and optional integer constants.\n\n    The constraint is: sum(left_nodes) + left_constant == sum(right_nodes) + right_constant.\n    \"\"\"\n\n    left_nodes: frozenset[str] = Field(default_factory=frozenset, description=\"Binary variables (left side)\")\n    right_nodes: frozenset[str] = Field(default_factory=frozenset, description=\"Binary variables (right side)\")\n    left_constant: int = Field(default=0, description=\"Constant term (left side)\")\n    right_constant: int = Field(default=0, description=\"Constant term (right side)\")\n\n    def __post_init__(self) -&gt; None:\n        # Check for duplicate variables\n        if len(self.left_nodes | self.right_nodes) != len(self.left_nodes) + len(self.right_nodes):\n            raise ValueError(\"Duplicate variables found between left_nodes and right_nodes\")\n\n    def __repr__(self) -&gt; str:\n        return f\"Switch(left={sorted(self.left_nodes)} + {self.left_constant}, right={sorted(self.right_nodes)} + {self.right_constant})\"\n\n    @property\n    def num_variables(self) -&gt; int:\n        \"\"\"Number of variables in this switch (left + right).\"\"\"\n        return len(self.left_nodes) + len(self.right_nodes)\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Number of quadratic terms if this switch were converted to QUBO alone.\"\"\"\n        return self.num_variables * (self.num_variables - 1) // 2\n\n    @classmethod\n    def to_qubo(cls, switches: list[Self]) -&gt; QUBO:\n        \"\"\"Convert a list of Switch elements into a single QUBO (sum of (L + c_L - R - c_R)^2 terms).\"\"\"\n        variables: set[str] = set()\n        quadratic: dict[frozenset[str], float] = defaultdict(float)\n        linear: dict[str, float] = defaultdict(float)\n        constant: float = 0\n\n        # Constant terms are not discarded\n        # At the call stage, each node in Switch is either NOT_CARE or ZERO_OR_ONE\n        # ALWAYS_ZERO and ALWAYS_ONE are processed as constant terms\n        # NOT_CARE is treated the same as ZERO_OR_ONE\n        for switch in switches:\n            # (L1 + L2 - R1 - R2 + C)^2\n            # = 2L1L2 + 2R1R2 - 2(L1R1 + ...)\n            # + L1 + L2 + R1 + R2 + 2C(L1 + L2 - R1 - R2)\n            # + C^2\n\n            switch_constant = switch.left_constant - switch.right_constant\n            variables.update(switch.left_nodes)\n            variables.update(switch.right_nodes)\n            # quadratic\n            for node1, node2 in combinations(switch.left_nodes, 2):\n                quadratic[frozenset((node1, node2))] += 2\n            for node1, node2 in combinations(switch.right_nodes, 2):\n                quadratic[frozenset((node1, node2))] += 2\n            for node1, node2 in product(switch.left_nodes, switch.right_nodes):\n                quadratic[frozenset((node1, node2))] -= 2\n            # linear\n            for node in switch.left_nodes:\n                linear[node] += 2 * switch_constant\n                linear[node] += 1  # Because x*x = x\n            for node in switch.right_nodes:\n                linear[node] -= 2 * switch_constant\n                linear[node] += 1\n            # constant\n            constant += switch_constant**2\n        qubo = QUBO(\n            variables=frozenset(variables),\n            quadratic=quadratic,\n            linear=linear,\n            constant=constant,\n        )\n\n        return qubo\n\n    @classmethod\n    def left_node_to_switch(cls, switches: list[Self]) -&gt; dict[str, int]:\n        \"\"\"Map each left-side variable name to the index of the switch that contains it.\"\"\"\n        left_node_to_switch: dict[str, int] = {}\n        for idx, switch in enumerate(switches):\n            for node in switch.left_nodes:\n                left_node_to_switch[node] = idx\n        return left_node_to_switch\n\n    @classmethod\n    def right_node_to_switch(cls, switches: list[Self]) -&gt; dict[str, int]:\n        \"\"\"Map each right-side variable name to the index of the switch that contains it.\"\"\"\n        right_node_to_switch: dict[str, int] = {}\n        for idx, switch in enumerate(switches):\n            for node in switch.right_nodes:\n                right_node_to_switch[node] = idx\n        return right_node_to_switch\n\n    @classmethod\n    def determine_layer_structure(\n        cls,\n        switches: list[Self],\n    ) -&gt; dict[int, list[int]]:\n        \"\"\"Determine which layer each switch belongs to. Returns {layer_number: [switch_indices]} (0-indexed).\"\"\"\n        left_node_to_switch = cls.left_node_to_switch(switches)\n        layer_structure: dict[int, list[int]] = {}\n        switch_idx_to_layer_number: dict[int, int] = {}\n\n        # Identify original variables (L0, L1, ...)\n        waiting_left_nodes: deque[tuple[str, int]] = deque()  # (node, layer_number)\n        for switch in switches:\n            for node in switch.left_nodes:\n                if re.match(r\"^L\\d+$\", node):\n                    waiting_left_nodes.append((node, 0))\n\n        # Determine the layer of each switch\n        while waiting_left_nodes:\n            node, layer_number = waiting_left_nodes.pop()\n            if node not in left_node_to_switch:\n                continue\n            if left_node_to_switch[node] in switch_idx_to_layer_number:\n                continue\n            switch_idx_to_layer_number[left_node_to_switch[node]] = layer_number\n            waiting_left_nodes.extend(\n                (node, layer_number + 1) for node in switches[left_node_to_switch[node]].right_nodes\n            )\n\n        for switch_idx, layer_number in switch_idx_to_layer_number.items():\n            if layer_number not in layer_structure:\n                layer_structure[layer_number] = []\n            layer_structure[layer_number].append(switch_idx)\n\n        return layer_structure\n\n    @classmethod\n    def visualize_switches(\n        cls,\n        switches: list[\"Switch\"],\n        output_path: str,\n        layout_type: str = \"network\",  # \"network\" or \"spring\"\n        layer_spacing: float = 2.0,\n        node_spacing: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Draw the relationship between variables and switches as a graph and save to output_path.\"\"\"\n        all_nodes: set[str] = set()\n        for switch in switches:\n            all_nodes.update(switch.left_nodes)\n            all_nodes.update(switch.right_nodes)\n\n        # Generate colors for each switch (same as generate_and_draw_qubo_network)\n        cmap = plt.get_cmap(\"tab10\")\n        switch_colors = [cmap(i % 10) for i in range(len(switches))]\n\n        graph: nx.Graph[str] = nx.Graph()\n        graph.add_nodes_from(all_nodes, node_color=\"blue\")\n\n        # Set colors for switch nodes\n        for switch_idx in range(len(switches)):\n            graph.add_node(\"C\" + str(switch_idx), node_color=switch_colors[switch_idx])\n\n        # Add constant nodes and set colors for edges\n        for switch_idx, switch in enumerate(switches):\n            switch_color = switch_colors[switch_idx]\n            for node in switch.left_nodes:\n                graph.add_edge(node, \"C\" + str(switch_idx), edge_color=switch_color)\n            for node in switch.right_nodes:\n                graph.add_edge(node, \"C\" + str(switch_idx), edge_color=switch_color)\n            if switch.left_constant != 0:\n                const_node = f\"LC_{switch_idx}_{switch.left_constant}\"\n                graph.add_node(const_node, node_color=\"g\")\n                graph.add_edge(\n                    const_node,\n                    \"C\" + str(switch_idx),\n                    edge_color=switch_color,\n                )\n            if switch.right_constant != 0:\n                const_node = f\"RC_{switch_idx}_{switch.right_constant}\"\n                graph.add_node(const_node, node_color=\"green\")\n                graph.add_edge(\n                    \"C\" + str(switch_idx),\n                    const_node,\n                    edge_color=switch_color,\n                )\n\n        # Determine layout\n        pos: dict[str, tuple[float, float]]\n        if layout_type == \"network\":\n            pos = cls._create_network_layout_with_layers(\n                switches,\n                all_nodes,\n                layer_spacing,\n                node_spacing,\n            )\n        else:\n            raw_pos = nx.spring_layout(graph)\n            pos = {node: (float(p[0]), float(p[1])) for node, p in raw_pos.items()}\n\n        edge_colors: list[str] = [graph[u][v][\"edge_color\"] for u, v in graph.edges()]\n\n        # Draw the graph\n        plt.figure(figsize=(max(12, len(switches) * 1.5), 10))\n\n        # Draw nodes by type\n        # Blue nodes (circle)\n        nx.draw_networkx_nodes(\n            graph,\n            pos,\n            nodelist=list(all_nodes),\n            node_color=\"blue\",\n            node_size=1500,\n            node_shape=\"o\",\n            alpha=0.5,\n        )\n        # switch nodes (square, different color for each switch)\n        for switch_idx in range(len(switches)):\n            switch_node = \"C\" + str(switch_idx)\n            nx.draw_networkx_nodes(\n                graph,\n                pos,\n                nodelist=[switch_node],\n                node_color=[switch_colors[switch_idx]],\n                node_size=5000,\n                node_shape=\"s\",\n                alpha=0.5,\n            )\n        # Green constant nodes (circle)\n        const_nodes = [node for node in graph.nodes() if node.startswith(\"LC_\") or node.startswith(\"RC_\")]\n        if const_nodes:\n            nx.draw_networkx_nodes(\n                graph,\n                pos,\n                nodelist=const_nodes,\n                node_color=\"green\",\n                node_size=1500,\n                node_shape=\"o\",\n                alpha=0.5,\n            )\n\n        # Draw edges and labels\n        nx.draw_networkx_edges(\n            graph,\n            pos,\n            edge_color=edge_colors,\n        )\n        nx.draw_networkx_labels(\n            graph,\n            pos,\n            font_size=12,\n            font_weight=\"bold\",\n        )\n\n        # Display layer information\n        if layout_type == \"network\":\n            layer_structure = cls.determine_layer_structure(switches)\n            cls._add_layer_labels(layer_structure, layer_spacing)\n            plt.title(\n                f\"Switches Network ({len(layer_structure)} layers)\",\n                fontsize=16,\n                fontweight=\"bold\",\n            )\n\n        plt.tight_layout()\n        plt.savefig(os.path.join(output_path, \"switches.png\"), dpi=300, bbox_inches=\"tight\")\n        plt.close()\n\n    @classmethod\n    def _create_network_layout_with_layers(\n        cls,\n        switches: list[\"Switch\"],\n        all_nodes: set[str],\n        layer_spacing: float,\n        node_spacing: float,\n    ) -&gt; dict[str, tuple[float, float]]:\n        \"\"\"\n        Create a manual layout based on layer structure\n        Layers are arranged to the right, and switches within each layer are arranged vertically\n        \"\"\"\n        pos = {}\n\n        # Determine layer structure\n        layer_structure = cls.determine_layer_structure(switches)\n\n        # Calculate position of each layer\n        for layer_num, switch_indices in sorted(layer_structure.items()):\n            x = (layer_num - 1) * layer_spacing\n\n            # Arrange switches vertically within each layer\n            for i, switch_idx in enumerate(switch_indices):\n                switch = switches[switch_idx]\n                switch_y = -(i - len(switch_indices) / 2) * node_spacing\n\n                # Place switch node\n                pos[f\"C{switch_idx}\"] = (x, switch_y)\n\n                # Place left nodes on the left (smaller index is higher, center aligns with switch node)\n                left_x_start = x - 0.8\n                sorted_left_nodes = sorted(switch.left_nodes)\n                for j, node in enumerate(sorted_left_nodes):\n                    y = switch_y - (j - (len(sorted_left_nodes) - 1) / 2) * 0.3\n                    pos[node] = (left_x_start, y)\n\n                # Place right nodes on the right (smaller index is higher, center aligns with switch node)\n                right_x_start = x + 0.8\n                sorted_right_nodes = sorted(switch.right_nodes)\n                for j, node in enumerate(sorted_right_nodes):\n                    y = switch_y - (j - (len(sorted_right_nodes) - 1) / 2) * 0.3\n                    pos[node] = (right_x_start, y)\n\n                # Place constant nodes (same height as switch node)\n                if switch.left_constant != 0:\n                    const_node = f\"LC_{switch_idx}_{switch.left_constant}\"\n                    pos[const_node] = (left_x_start, switch_y)\n                if switch.right_constant != 0:\n                    const_node = f\"RC_{switch_idx}_{switch.right_constant}\"\n                    pos[const_node] = (right_x_start, switch_y)\n\n        # Place other nodes (unconnected nodes) in appropriate positions\n        used_nodes = set(pos.keys())\n        unused_nodes = all_nodes - used_nodes\n\n        if unused_nodes:\n            # Place unused nodes to the right of the last layer\n            max_layer = max(layer_structure.keys()) if layer_structure else 1\n            last_x = (max_layer - 1) * layer_spacing + 1.5\n            for i, node in enumerate(sorted(unused_nodes)):\n                pos[node] = (last_x, -2.0 - i * node_spacing)\n\n        return pos\n\n    @classmethod\n    def _add_layer_labels(\n        cls,\n        layer_structure: dict[int, list[int]],\n        layer_spacing: float,\n    ) -&gt; None:\n        \"\"\"\n        Add layer labels\n        \"\"\"\n        for layer_num, _ in layer_structure.items():\n            x = (layer_num - 1) * layer_spacing\n            # Place layer labels at the top of each layer\n            plt.text(\n                x,\n                3.0,\n                f\"Layer {layer_num}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=14,\n                fontweight=\"bold\",\n                bbox={\"boxstyle\": \"round,pad=0.3\", \"facecolor\": \"lightblue\", \"alpha\": 0.7},\n            )\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Number of quadratic terms if this switch were converted to QUBO alone.</p>"},{"location":"modules/#sparse_qubo.core.switch.Switch.num_variables","title":"<code>num_variables</code>  <code>property</code>","text":"<p>Number of variables in this switch (left + right).</p>"},{"location":"modules/#sparse_qubo.core.switch.Switch.determine_layer_structure","title":"<code>determine_layer_structure(switches)</code>  <code>classmethod</code>","text":"<p>Determine which layer each switch belongs to. Returns {layer_number: [switch_indices]} (0-indexed).</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>@classmethod\ndef determine_layer_structure(\n    cls,\n    switches: list[Self],\n) -&gt; dict[int, list[int]]:\n    \"\"\"Determine which layer each switch belongs to. Returns {layer_number: [switch_indices]} (0-indexed).\"\"\"\n    left_node_to_switch = cls.left_node_to_switch(switches)\n    layer_structure: dict[int, list[int]] = {}\n    switch_idx_to_layer_number: dict[int, int] = {}\n\n    # Identify original variables (L0, L1, ...)\n    waiting_left_nodes: deque[tuple[str, int]] = deque()  # (node, layer_number)\n    for switch in switches:\n        for node in switch.left_nodes:\n            if re.match(r\"^L\\d+$\", node):\n                waiting_left_nodes.append((node, 0))\n\n    # Determine the layer of each switch\n    while waiting_left_nodes:\n        node, layer_number = waiting_left_nodes.pop()\n        if node not in left_node_to_switch:\n            continue\n        if left_node_to_switch[node] in switch_idx_to_layer_number:\n            continue\n        switch_idx_to_layer_number[left_node_to_switch[node]] = layer_number\n        waiting_left_nodes.extend(\n            (node, layer_number + 1) for node in switches[left_node_to_switch[node]].right_nodes\n        )\n\n    for switch_idx, layer_number in switch_idx_to_layer_number.items():\n        if layer_number not in layer_structure:\n            layer_structure[layer_number] = []\n        layer_structure[layer_number].append(switch_idx)\n\n    return layer_structure\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch.left_node_to_switch","title":"<code>left_node_to_switch(switches)</code>  <code>classmethod</code>","text":"<p>Map each left-side variable name to the index of the switch that contains it.</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>@classmethod\ndef left_node_to_switch(cls, switches: list[Self]) -&gt; dict[str, int]:\n    \"\"\"Map each left-side variable name to the index of the switch that contains it.\"\"\"\n    left_node_to_switch: dict[str, int] = {}\n    for idx, switch in enumerate(switches):\n        for node in switch.left_nodes:\n            left_node_to_switch[node] = idx\n    return left_node_to_switch\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch.right_node_to_switch","title":"<code>right_node_to_switch(switches)</code>  <code>classmethod</code>","text":"<p>Map each right-side variable name to the index of the switch that contains it.</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>@classmethod\ndef right_node_to_switch(cls, switches: list[Self]) -&gt; dict[str, int]:\n    \"\"\"Map each right-side variable name to the index of the switch that contains it.\"\"\"\n    right_node_to_switch: dict[str, int] = {}\n    for idx, switch in enumerate(switches):\n        for node in switch.right_nodes:\n            right_node_to_switch[node] = idx\n    return right_node_to_switch\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch.to_qubo","title":"<code>to_qubo(switches)</code>  <code>classmethod</code>","text":"<p>Convert a list of Switch elements into a single QUBO (sum of (L + c_L - R - c_R)^2 terms).</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>@classmethod\ndef to_qubo(cls, switches: list[Self]) -&gt; QUBO:\n    \"\"\"Convert a list of Switch elements into a single QUBO (sum of (L + c_L - R - c_R)^2 terms).\"\"\"\n    variables: set[str] = set()\n    quadratic: dict[frozenset[str], float] = defaultdict(float)\n    linear: dict[str, float] = defaultdict(float)\n    constant: float = 0\n\n    # Constant terms are not discarded\n    # At the call stage, each node in Switch is either NOT_CARE or ZERO_OR_ONE\n    # ALWAYS_ZERO and ALWAYS_ONE are processed as constant terms\n    # NOT_CARE is treated the same as ZERO_OR_ONE\n    for switch in switches:\n        # (L1 + L2 - R1 - R2 + C)^2\n        # = 2L1L2 + 2R1R2 - 2(L1R1 + ...)\n        # + L1 + L2 + R1 + R2 + 2C(L1 + L2 - R1 - R2)\n        # + C^2\n\n        switch_constant = switch.left_constant - switch.right_constant\n        variables.update(switch.left_nodes)\n        variables.update(switch.right_nodes)\n        # quadratic\n        for node1, node2 in combinations(switch.left_nodes, 2):\n            quadratic[frozenset((node1, node2))] += 2\n        for node1, node2 in combinations(switch.right_nodes, 2):\n            quadratic[frozenset((node1, node2))] += 2\n        for node1, node2 in product(switch.left_nodes, switch.right_nodes):\n            quadratic[frozenset((node1, node2))] -= 2\n        # linear\n        for node in switch.left_nodes:\n            linear[node] += 2 * switch_constant\n            linear[node] += 1  # Because x*x = x\n        for node in switch.right_nodes:\n            linear[node] -= 2 * switch_constant\n            linear[node] += 1\n        # constant\n        constant += switch_constant**2\n    qubo = QUBO(\n        variables=frozenset(variables),\n        quadratic=quadratic,\n        linear=linear,\n        constant=constant,\n    )\n\n    return qubo\n</code></pre>"},{"location":"modules/#sparse_qubo.core.switch.Switch.visualize_switches","title":"<code>visualize_switches(switches, output_path, layout_type='network', layer_spacing=2.0, node_spacing=1.0)</code>  <code>classmethod</code>","text":"<p>Draw the relationship between variables and switches as a graph and save to output_path.</p> Source code in <code>src/sparse_qubo/core/switch.py</code> <pre><code>@classmethod\ndef visualize_switches(\n    cls,\n    switches: list[\"Switch\"],\n    output_path: str,\n    layout_type: str = \"network\",  # \"network\" or \"spring\"\n    layer_spacing: float = 2.0,\n    node_spacing: float = 1.0,\n) -&gt; None:\n    \"\"\"Draw the relationship between variables and switches as a graph and save to output_path.\"\"\"\n    all_nodes: set[str] = set()\n    for switch in switches:\n        all_nodes.update(switch.left_nodes)\n        all_nodes.update(switch.right_nodes)\n\n    # Generate colors for each switch (same as generate_and_draw_qubo_network)\n    cmap = plt.get_cmap(\"tab10\")\n    switch_colors = [cmap(i % 10) for i in range(len(switches))]\n\n    graph: nx.Graph[str] = nx.Graph()\n    graph.add_nodes_from(all_nodes, node_color=\"blue\")\n\n    # Set colors for switch nodes\n    for switch_idx in range(len(switches)):\n        graph.add_node(\"C\" + str(switch_idx), node_color=switch_colors[switch_idx])\n\n    # Add constant nodes and set colors for edges\n    for switch_idx, switch in enumerate(switches):\n        switch_color = switch_colors[switch_idx]\n        for node in switch.left_nodes:\n            graph.add_edge(node, \"C\" + str(switch_idx), edge_color=switch_color)\n        for node in switch.right_nodes:\n            graph.add_edge(node, \"C\" + str(switch_idx), edge_color=switch_color)\n        if switch.left_constant != 0:\n            const_node = f\"LC_{switch_idx}_{switch.left_constant}\"\n            graph.add_node(const_node, node_color=\"g\")\n            graph.add_edge(\n                const_node,\n                \"C\" + str(switch_idx),\n                edge_color=switch_color,\n            )\n        if switch.right_constant != 0:\n            const_node = f\"RC_{switch_idx}_{switch.right_constant}\"\n            graph.add_node(const_node, node_color=\"green\")\n            graph.add_edge(\n                \"C\" + str(switch_idx),\n                const_node,\n                edge_color=switch_color,\n            )\n\n    # Determine layout\n    pos: dict[str, tuple[float, float]]\n    if layout_type == \"network\":\n        pos = cls._create_network_layout_with_layers(\n            switches,\n            all_nodes,\n            layer_spacing,\n            node_spacing,\n        )\n    else:\n        raw_pos = nx.spring_layout(graph)\n        pos = {node: (float(p[0]), float(p[1])) for node, p in raw_pos.items()}\n\n    edge_colors: list[str] = [graph[u][v][\"edge_color\"] for u, v in graph.edges()]\n\n    # Draw the graph\n    plt.figure(figsize=(max(12, len(switches) * 1.5), 10))\n\n    # Draw nodes by type\n    # Blue nodes (circle)\n    nx.draw_networkx_nodes(\n        graph,\n        pos,\n        nodelist=list(all_nodes),\n        node_color=\"blue\",\n        node_size=1500,\n        node_shape=\"o\",\n        alpha=0.5,\n    )\n    # switch nodes (square, different color for each switch)\n    for switch_idx in range(len(switches)):\n        switch_node = \"C\" + str(switch_idx)\n        nx.draw_networkx_nodes(\n            graph,\n            pos,\n            nodelist=[switch_node],\n            node_color=[switch_colors[switch_idx]],\n            node_size=5000,\n            node_shape=\"s\",\n            alpha=0.5,\n        )\n    # Green constant nodes (circle)\n    const_nodes = [node for node in graph.nodes() if node.startswith(\"LC_\") or node.startswith(\"RC_\")]\n    if const_nodes:\n        nx.draw_networkx_nodes(\n            graph,\n            pos,\n            nodelist=const_nodes,\n            node_color=\"green\",\n            node_size=1500,\n            node_shape=\"o\",\n            alpha=0.5,\n        )\n\n    # Draw edges and labels\n    nx.draw_networkx_edges(\n        graph,\n        pos,\n        edge_color=edge_colors,\n    )\n    nx.draw_networkx_labels(\n        graph,\n        pos,\n        font_size=12,\n        font_weight=\"bold\",\n    )\n\n    # Display layer information\n    if layout_type == \"network\":\n        layer_structure = cls.determine_layer_structure(switches)\n        cls._add_layer_labels(layer_structure, layer_spacing)\n        plt.title(\n            f\"Switches Network ({len(layer_structure)} layers)\",\n            fontsize=16,\n            fontweight=\"bold\",\n        )\n\n    plt.tight_layout()\n    plt.savefig(os.path.join(output_path, \"switches.png\"), dpi=300, bbox_inches=\"tight\")\n    plt.close()\n</code></pre>"},{"location":"modules/#network-implementations","title":"Network implementations","text":""},{"location":"modules/#sparse_qubo.networks.benes_network","title":"<code>sparse_qubo.networks.benes_network</code>","text":"<p>Implementation of Benes network</p>"},{"location":"modules/#sparse_qubo.networks.benes_network.BenesNetwork","title":"<code>BenesNetwork</code>","text":"<p>               Bases: <code>ClosNetworkBase</code></p> <p>Benes network implementation; requires power-of-2 variable count.</p> Source code in <code>src/sparse_qubo/networks/benes_network.py</code> <pre><code>class BenesNetwork(ClosNetworkBase):\n    \"\"\"Benes network implementation; requires power-of-2 variable count.\"\"\"\n\n    @classmethod\n    def _implement_if_small(cls, left_nodes: list[str], right_nodes: list[str]) -&gt; list[Switch] | None:\n        N = max(len(left_nodes), len(right_nodes))\n        if N &lt;= 2:\n            return [\n                Switch(\n                    left_nodes=frozenset(left_nodes),\n                    right_nodes=frozenset(right_nodes),\n                )\n            ]\n        return None\n\n    @classmethod\n    def _determine_switch_sizes(cls, N_left: int, N_right: int) -&gt; tuple[int, int]:\n        \"\"\"Return (n, r) for Benes network with n*r &gt;= N.\"\"\"\n        N = max(N_left, N_right)\n        n, r = 2, 1\n        while n * r &lt; N:\n            r *= 2\n        return n, r\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.bitonic_sort_network","title":"<code>sparse_qubo.networks.bitonic_sort_network</code>","text":"<p>Implementation of Bitonic sort network</p>"},{"location":"modules/#sparse_qubo.networks.bitonic_sort_network.BitonicSortNetwork","title":"<code>BitonicSortNetwork</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code></p> <p>Bitonic sort network; requires power-of-2 variable count.</p> Source code in <code>src/sparse_qubo/networks/bitonic_sort_network.py</code> <pre><code>class BitonicSortNetwork(ISwitchingNetwork):\n    \"\"\"Bitonic sort network; requires power-of-2 variable count.\"\"\"\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Return the list of Switch elements for the bitonic sort network.\"\"\"\n        left_names = [node.name for node in left_nodes]\n        right_names = [node.name for node in right_nodes]\n        if len(left_names) != len(right_names):\n            raise ValueError(\"left_nodes and right_nodes must have the same length\")\n        N: int = len(left_names)\n        n: int = round(log2(N))\n        if 2**n != N:\n            raise ValueError(\"N must be a power of 2\")\n        if not reverse:\n            left_names, right_names = right_names, left_names\n\n        all_nodes: list[list[str]] = [[] for _ in range(N)]\n        for i in range(N):\n            all_nodes[i].append(left_names[i])\n            for j in range(n * (n + 1) // 2 - 1):\n                all_nodes[i].append(f\"{left_names[i]}_{j}_{right_names[i]}\")\n            all_nodes[i].append(right_names[i])\n\n        progress: list[int] = [0] * N\n        result_switches: list[Switch] = []\n        # m is called in the order (0, 1, 2, 3), (0, 1, 2), (0, 1), (0)\n        if reverse:\n            for m_max in range(n)[::-1]:\n                for m in range(m_max + 1):\n                    M = 2**m\n                    for i in range(N):\n                        if (i // M) % 2 == 0:\n                            result_switches.append(\n                                Switch(\n                                    left_nodes=frozenset([\n                                        all_nodes[i][progress[i]],\n                                        all_nodes[i + M][progress[i + M]],\n                                    ]),\n                                    right_nodes=frozenset([\n                                        all_nodes[i][progress[i] + 1],\n                                        all_nodes[i + M][progress[i + M] + 1],\n                                    ]),\n                                )\n                            )\n                            progress[i] += 1\n                            progress[i + M] += 1\n            return result_switches\n        else:\n            for m_max in range(n)[::-1]:\n                for m in range(m_max + 1):\n                    M = 2**m\n                    for i in range(N):\n                        if (i // M) % 2 == 0:\n                            result_switches.append(\n                                Switch(\n                                    left_nodes=frozenset([\n                                        all_nodes[i][progress[i] + 1],\n                                        all_nodes[i + M][progress[i + M] + 1],\n                                    ]),\n                                    right_nodes=frozenset([\n                                        all_nodes[i][progress[i]],\n                                        all_nodes[i + M][progress[i + M]],\n                                    ]),\n                                )\n                            )\n                            progress[i] += 1\n                            progress[i + M] += 1\n            return result_switches[::-1]\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.bubble_sort_network","title":"<code>sparse_qubo.networks.bubble_sort_network</code>","text":"<p>Implementation of Bubble sort network</p>"},{"location":"modules/#sparse_qubo.networks.bubble_sort_network.BubbleSortNetwork","title":"<code>BubbleSortNetwork</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code></p> <p>Bubble sort network; works for any variable count.</p> Source code in <code>src/sparse_qubo/networks/bubble_sort_network.py</code> <pre><code>class BubbleSortNetwork(ISwitchingNetwork):\n    \"\"\"Bubble sort network; works for any variable count.\"\"\"\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Return the list of Switch elements for the bubble sort network.\"\"\"\n        left_names = [node.name for node in left_nodes]\n        right_names = [node.name for node in right_nodes]\n        if len(left_names) != len(right_names):\n            raise ValueError(\"left_nodes and right_nodes must have the same length\")\n        N: int = len(left_names)\n\n        all_nodes: list[list[str]] = [[] for _ in range(N)]\n        for i in range(N):\n            all_nodes[i].append(left_names[i])\n            for j in range((N - 1 - i) * 2 if i &gt; 0 else N - 2):\n                all_nodes[i].append(f\"{left_names[i]}_{j}_{right_names[i]}\")\n            all_nodes[i].append(right_names[i])\n\n        progress: list[int] = [0] * N\n        result_switches: list[Switch] = []\n        for i in list(range(1, N)) + list(range(1, N - 1)[::-1]):\n            for j in range(0, i, 2):\n                k1, k2 = i - j, i - j - 1\n                result_switches.append(\n                    Switch(\n                        left_nodes=frozenset([all_nodes[k1][progress[k1]], all_nodes[k2][progress[k2]]]),\n                        right_nodes=frozenset([\n                            all_nodes[k1][progress[k1] + 1],\n                            all_nodes[k2][progress[k2] + 1],\n                        ]),\n                    )\n                )\n                progress[k1] += 1\n                progress[k2] += 1\n        return result_switches\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clique_network","title":"<code>sparse_qubo.networks.clique_network</code>","text":"<p>Implementation of clique network: single all-to-all switch between left and right variables.</p>"},{"location":"modules/#sparse_qubo.networks.clique_network.CliqueNetwork","title":"<code>CliqueNetwork</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code></p> <p>Single switch connecting all left variables to all right variables (clique).</p> Source code in <code>src/sparse_qubo/networks/clique_network.py</code> <pre><code>class CliqueNetwork(ISwitchingNetwork):\n    \"\"\"Single switch connecting all left variables to all right variables (clique).\"\"\"\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Return a single Switch with all left and all right variables.\"\"\"\n        left_names = [node.name for node in left_nodes]\n        right_names = [node.name for node in right_nodes]\n        return [\n            Switch(\n                left_nodes=frozenset(left_names),\n                right_nodes=frozenset(right_names),\n            )\n        ]\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clos_network_base","title":"<code>sparse_qubo.networks.clos_network_base</code>","text":"<p>Implementation of Clos network base: three-stage switching network with configurable switch sizes.</p>"},{"location":"modules/#sparse_qubo.networks.clos_network_base.ClosNetworkBase","title":"<code>ClosNetworkBase</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code>, <code>ABC</code></p> <p>Base class for Clos-type networks (ingress, middle, egress stages).</p> Source code in <code>src/sparse_qubo/networks/clos_network_base.py</code> <pre><code>class ClosNetworkBase(ISwitchingNetwork, ABC):\n    \"\"\"Base class for Clos-type networks (ingress, middle, egress stages).\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _implement_if_small(cls, left_nodes: list[str], right_nodes: list[str]) -&gt; list[Switch] | None:\n        \"\"\"Return a small network for small N, or None to use the full Clos construction.\"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def _determine_switch_sizes(cls, N_left: int, N_right: int) -&gt; tuple[int, int]:\n        \"\"\"Return (n, r) for exterior switch size n and number of interior switches r.\"\"\"\n        pass\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Build the three-stage Clos network (ingress, middle, egress).\"\"\"\n        left_names = [node.name for node in left_nodes]\n        right_names = [node.name for node in right_nodes]\n\n        if result := cls._implement_if_small(left_names, right_names):\n            return result\n\n        left_size: int = len(left_names)\n        right_size: int = len(right_names)\n        exterior_switch_size, interior_switch_size = cls._determine_switch_sizes(left_size, right_size)\n        intermediate_node_size: int = exterior_switch_size * interior_switch_size\n        if max(left_size, right_size) &gt; intermediate_node_size:\n            raise ValueError(\"switch size is too small\")\n\n        # Generate switches for the ingress stage\n        ingress_stage_switches: list[Switch] = []\n        ingress_stage_nodes: list[str] = []\n        interior_index_start: int\n        interior_index_end: int\n        interior_node_names: list[str]\n        for r in range(interior_switch_size):\n            left_index_start: int = r * left_size // interior_switch_size\n            left_index_end: int = (r + 1) * left_size // interior_switch_size\n            interior_index_start = exterior_switch_size * r\n            interior_index_end = exterior_switch_size * (r + 1)\n\n            interior_node_names = [\n                f\"{left_names[min(i, left_index_end - 1)]}_{i}\" for i in range(interior_index_start, interior_index_end)\n            ]\n            ingress_stage_switches.append(\n                Switch(\n                    left_nodes=frozenset(left_names[left_index_start:left_index_end]),\n                    right_nodes=frozenset(interior_node_names),\n                )\n            )\n            ingress_stage_nodes.extend(interior_node_names)\n\n        # Generate switches for the egress stage\n        egress_stage_switches: list[Switch] = []\n        egress_stage_nodes: list[str] = []\n        for r in range(interior_switch_size):\n            right_index_start: int = r * right_size // interior_switch_size\n            right_index_end: int = (r + 1) * right_size // interior_switch_size\n            interior_index_start = exterior_switch_size * r\n            interior_index_end = exterior_switch_size * (r + 1)\n\n            interior_node_names = [\n                f\"{right_names[min(i, right_index_end - 1)]}_{i}\"\n                for i in range(interior_index_start, interior_index_end)\n            ]\n            egress_stage_switches.append(\n                Switch(\n                    left_nodes=frozenset(interior_node_names),\n                    right_nodes=frozenset(right_names[right_index_start:right_index_end]),\n                )\n            )\n            egress_stage_nodes.extend(interior_node_names)\n\n        # # Generate switches for the middle stage\n        # middle_stage_switches: list[Switch] = []\n        # for i_start in range(exterior_switch_size):\n        #     middle_stage_switches.extend(\n        #         cls._generate_original_network(\n        #             ingress_stage_nodes[i_start:intermediate_node_size:exterior_switch_size],\n        #             egress_stage_nodes[i_start:intermediate_node_size:exterior_switch_size],\n        #         )\n        #     )\n\n        # Generate switches for the middle stage\n        middle_stage_switches: list[Switch] = []\n        for i_start in range(exterior_switch_size):\n            # 1. First, get string slices (sub-lists)\n            sub_left_names = ingress_stage_nodes[i_start:intermediate_node_size:exterior_switch_size]\n            sub_right_names = egress_stage_nodes[i_start:intermediate_node_size:exterior_switch_size]\n\n            # 2. Convert to VariableNode and make recursive call\n            middle_stage_switches.extend(\n                cls._generate_original_network(\n                    left_nodes=[VariableNode(name=n) for n in sub_left_names],\n                    right_nodes=[VariableNode(name=n) for n in sub_right_names],\n                    threshold=threshold,\n                    reverse=reverse,\n                )\n            )\n\n        # Connect the three and return\n        return ingress_stage_switches + middle_stage_switches + egress_stage_switches\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clos_network_max_degree","title":"<code>sparse_qubo.networks.clos_network_max_degree</code>","text":"<p>Implementation of Clos network with maximum degree constraint: limits the size of each switch.</p>"},{"location":"modules/#sparse_qubo.networks.clos_network_max_degree.AdhocNetworkWithMinimumDegree","title":"<code>AdhocNetworkWithMinimumDegree</code>","text":"<p>Helper for small networks when max degree is large enough (single switch).</p> Source code in <code>src/sparse_qubo/networks/clos_network_max_degree.py</code> <pre><code>class AdhocNetworkWithMinimumDegree:\n    \"\"\"Helper for small networks when max degree is large enough (single switch).\"\"\"\n\n    @classmethod\n    def implement_if_small(cls, left_nodes: list[str], right_nodes: list[str], max_degree: int) -&gt; list[Switch]:\n        N = max(len(left_nodes), len(right_nodes))\n        if N &lt; 2:\n            raise ValueError(\"N must be greater than or equal to 2\")\n        if max_degree &gt;= N:\n            return [\n                Switch(\n                    left_nodes=frozenset(left_nodes),\n                    right_nodes=frozenset(right_nodes),\n                )\n            ]\n        # elif N &lt;= max_degree * 1.5:\n        #     first_vars: list[str] = [\n        #         f\"{left_nodes[i]}_{right_nodes[i]}\"\n        #         for i in range(math.floor(max_degree / 2))\n        #     ]\n        #     second_left_vars: list[str] = [\n        #         f\"{left_nodes[i]}_{i}\"\n        #         for i in range(math.floor(max_degree / 2), max_degree)\n        #     ]\n        #     second_right_vars: list[str] = [\n        #         f\"{right_nodes[i]}_{i}\"\n        #         for i in range(math.floor(max_degree / 2), max_degree)\n        #     ]\n        #     return [\n        #         Switch(\n        #             left_nodes=frozenset(left_nodes[:max_degree]),\n        #             right_nodes=frozenset(first_vars + second_left_vars),\n        #         ),\n        #         Switch(\n        #             left_nodes=frozenset(second_left_vars + left_nodes[max_degree:]),\n        #             right_nodes=frozenset(second_right_vars + right_nodes[max_degree:]),\n        #         ),\n        #         Switch(\n        #             left_nodes=frozenset(first_vars + second_right_vars),\n        #             right_nodes=frozenset(right_nodes[:max_degree]),\n        #         ),\n        #     ]\n        # TODO: Needs confirmation\n        else:\n            return []\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clos_network_max_degree.ClosNetworkWithMaxDegree","title":"<code>ClosNetworkWithMaxDegree</code>","text":"<p>               Bases: <code>ClosNetworkBase</code></p> <p>Clos network that limits the maximum degree (switch size). Call reset_max_degree before use.</p> Source code in <code>src/sparse_qubo/networks/clos_network_max_degree.py</code> <pre><code>class ClosNetworkWithMaxDegree(ClosNetworkBase):\n    \"\"\"Clos network that limits the maximum degree (switch size). Call reset_max_degree before use.\"\"\"\n\n    num_elements_dict: ClassVar[dict[int, int]] = {}\n    max_degree: ClassVar[int] = 5\n\n    @classmethod\n    def reset_max_degree(cls, new_max: int) -&gt; None:\n        \"\"\"Set the maximum allowed degree (switch size) for the network.\"\"\"\n        if new_max &lt; 2:\n            raise ValueError(\"new_max must be greater than or equal to 2\")\n\n        cls.num_elements_dict = {}\n        cls.max_degree = new_max\n\n    # Number of comparators when implementing a network of size N based on (n, r)\n    @classmethod\n    def _calc_num_elements(cls, N: int, n: int, r: int) -&gt; int:\n        interior_cost = cls._get_estimated_cost_and_implementation(r) * n\n        exterior_cost = r\n        return exterior_cost * 2 + interior_cost\n\n    # Return the number of comparators\n    @classmethod\n    def _get_estimated_cost_and_implementation(cls, N: int) -&gt; int:\n        if N not in cls.num_elements_dict:\n            if adhoc_network := cls._implement_if_small([f\"L{i}\" for i in range(N)], [f\"R{i}\" for i in range(N)]):\n                cls.num_elements_dict[N] = len(adhoc_network)\n            else:\n                n_opt, r_opt = cls._determine_switch_sizes(N, N)\n                cls.num_elements_dict[N] = cls._calc_num_elements(N, n_opt, r_opt)\n        return cls.num_elements_dict[N]\n\n    # Return optimal (n, r)\n    @classmethod\n    def _determine_switch_sizes(cls, N_left: int, N_right: int) -&gt; tuple[int, int]:\n        if cls.max_degree is None:\n            raise RuntimeError(\"max_degree is None\")\n\n        N = max(N_left, N_right)\n\n        nr_list: list[tuple[int, int]] = [(n, (N + n - 1) // n) for n in range(2, cls.max_degree + 1)]\n        n_opt, r_opt = min(nr_list, key=lambda x: cls._calc_num_elements(N, x[0], x[1]))\n        return n_opt, r_opt\n\n    # Return implementation for small cases\n    @classmethod\n    def _implement_if_small(cls, left_nodes: list[str], right_nodes: list[str]) -&gt; list[Switch] | None:\n        if cls.max_degree is None:\n            raise RuntimeError(\"max_degree is None\")\n\n        return AdhocNetworkWithMinimumDegree.implement_if_small(left_nodes, right_nodes, cls.max_degree)\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clos_network_max_degree.ClosNetworkWithMaxDegree.reset_max_degree","title":"<code>reset_max_degree(new_max)</code>  <code>classmethod</code>","text":"<p>Set the maximum allowed degree (switch size) for the network.</p> Source code in <code>src/sparse_qubo/networks/clos_network_max_degree.py</code> <pre><code>@classmethod\ndef reset_max_degree(cls, new_max: int) -&gt; None:\n    \"\"\"Set the maximum allowed degree (switch size) for the network.\"\"\"\n    if new_max &lt; 2:\n        raise ValueError(\"new_max must be greater than or equal to 2\")\n\n    cls.num_elements_dict = {}\n    cls.max_degree = new_max\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.clos_network_minimum_edge","title":"<code>sparse_qubo.networks.clos_network_minimum_edge</code>","text":"<p>Implementation of Clos network with minimum edge count: chooses (n, r) to minimize quadratic terms.</p>"},{"location":"modules/#sparse_qubo.networks.clos_network_minimum_edge.ClosNetworkMinimumEdge","title":"<code>ClosNetworkMinimumEdge</code>","text":"<p>               Bases: <code>ClosNetworkBase</code></p> <p>Clos network that minimizes the number of logical edges (quadratic terms).</p> Source code in <code>src/sparse_qubo/networks/clos_network_minimum_edge.py</code> <pre><code>class ClosNetworkMinimumEdge(ClosNetworkBase):\n    \"\"\"Clos network that minimizes the number of logical edges (quadratic terms).\"\"\"\n\n    is_small_dict: ClassVar[dict[int, bool]] = dict.fromkeys(range(3), True)\n    num_logical_edges_dict: ClassVar[dict[int, int]] = {0: 0, 1: 0, 2: 6}\n\n    # Number of logical edges when implementing a network of size N based on (n, r)\n    @classmethod\n    def _calc_num_logical_edges(cls, N: int, n: int, r: int) -&gt; int:\n        interior_cost = cls._get_estimated_cost_and_implementation(r)[0] * n\n        exterior_cost = 0\n        for r_idx in range(r):\n            input_start_idx = N * r_idx // r\n            input_end_idx = N * (r_idx + 1) // r\n            total_nodes = input_end_idx - input_start_idx + n\n            exterior_cost += total_nodes * (total_nodes - 1) // 2\n        return exterior_cost * 2 + interior_cost\n\n    # Return the number of logical edges and implementation method (whether clique or not)\n    @classmethod\n    def _get_estimated_cost_and_implementation(cls, N: int) -&gt; tuple[int, bool]:\n        if N not in cls.num_logical_edges_dict:\n            n_opt, r_opt = cls._determine_switch_sizes(N, N)\n            cost_division = cls._calc_num_logical_edges(N, n_opt, r_opt)\n            cost_clique = N * (N * 2 - 1)\n            cls.is_small_dict[N] = cost_clique &lt;= cost_division\n            cls.num_logical_edges_dict[N] = min(cost_clique, cost_division)\n        return cls.num_logical_edges_dict[N], cls.is_small_dict[N]\n\n    # Return optimal (n, r)\n    @classmethod\n    def _determine_switch_sizes(cls, N_left: int, N_right: int) -&gt; tuple[int, int]:\n        N = max(N_left, N_right)\n\n        # r = (N + n - 1) // n is the minimum r that satisfies n*r &gt;= N\n        nr_list: list[tuple[int, int]] = [(n, (N + n - 1) // n) for n in range(2, N)]\n        n_opt, r_opt = min(nr_list, key=lambda x: cls._calc_num_logical_edges(N, x[0], x[1]))\n        return n_opt, r_opt\n\n    # Return implementation for small cases\n    @classmethod\n    def _implement_if_small(cls, left_nodes: list[str], right_nodes: list[str]) -&gt; list[Switch] | None:\n        N = max(len(left_nodes), len(right_nodes))\n        is_small = cls._get_estimated_cost_and_implementation(N)[1]\n        if is_small:\n            return [\n                Switch(\n                    left_nodes=frozenset(left_nodes),\n                    right_nodes=frozenset(right_nodes),\n                )\n            ]\n        else:\n            return None\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.divide_and_conquer_network","title":"<code>sparse_qubo.networks.divide_and_conquer_network</code>","text":"<p>Implementation of Divide-and-conquer network: recursive division of the constraint.</p>"},{"location":"modules/#sparse_qubo.networks.divide_and_conquer_network.DivideAndConquerNetwork","title":"<code>DivideAndConquerNetwork</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code></p> <p>Divide-and-conquer switching network; uses BubbleSort when size is small or one-hot.</p> Source code in <code>src/sparse_qubo/networks/divide_and_conquer_network.py</code> <pre><code>class DivideAndConquerNetwork(ISwitchingNetwork):\n    \"\"\"Divide-and-conquer switching network; uses BubbleSort when size is small or one-hot.\"\"\"\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = False,\n    ) -&gt; list[Switch]:\n        \"\"\"Return the list of Switch elements; recurses or uses BubbleSort for one-hot/small cases.\"\"\"\n        if len(left_nodes) != len(right_nodes):\n            raise ValueError(\"left_nodes and right_nodes must have the same length\")\n\n        num_variables: int = len(left_nodes)\n\n        node_dict: defaultdict[NodeAttribute, list[VariableNode]] = defaultdict(list)\n        for node in right_nodes:\n            node_dict[node.attribute].append(node)\n\n        # TODO: Currently only supports equal to\n        if len(node_dict[NodeAttribute.ZERO_OR_ONE]) != 0:\n            raise ValueError(\"ZERO_OR_ONE nodes are not supported\")\n        if len(node_dict[NodeAttribute.NOT_CARE]) != 0:\n            raise ValueError(\"NOT_CARE nodes are not supported\")\n        if len(node_dict[NodeAttribute.ALWAYS_ZERO]) + len(node_dict[NodeAttribute.ALWAYS_ONE]) != num_variables:\n            raise ValueError(\"right_nodes must consist only of ALWAYS_ZERO and ALWAYS_ONE nodes\")\n        if not all(node.attribute == NodeAttribute.ZERO_OR_ONE for node in left_nodes):\n            raise ValueError(\"All left_nodes must have ZERO_OR_ONE attribute\")\n\n        switches: list[Switch] = []\n\n        if (\n            len(node_dict[NodeAttribute.ALWAYS_ZERO]) == num_variables\n            or len(node_dict[NodeAttribute.ALWAYS_ONE]) == num_variables\n        ):\n            switches.extend([\n                Switch(\n                    left_nodes=frozenset([left_node.name]),\n                    right_nodes=frozenset([right_node.name]),\n                )\n                for left_node, right_node in zip(left_nodes, right_nodes, strict=True)\n            ])\n            return switches\n\n        # Case of one-hot\n        if len(node_dict[NodeAttribute.ALWAYS_ONE]) == 1:\n            switches.extend(\n                BubbleSortNetwork._generate_original_network(\n                    left_nodes,\n                    node_dict[NodeAttribute.ALWAYS_ZERO] + node_dict[NodeAttribute.ALWAYS_ONE],\n                )\n            )\n            return switches\n        elif len(node_dict[NodeAttribute.ALWAYS_ZERO]) == 1:\n            switches.extend(\n                BubbleSortNetwork._generate_original_network(\n                    left_nodes,\n                    node_dict[NodeAttribute.ALWAYS_ONE] + node_dict[NodeAttribute.ALWAYS_ZERO],\n                )\n            )\n            return switches\n        # Other cases\n        else:\n            if threshold is not None and num_variables &lt;= threshold:\n                switches.append(\n                    Switch(\n                        left_nodes=frozenset([left_node.name for left_node in left_nodes]),\n                        right_nodes=frozenset([right_node.name for right_node in right_nodes]),\n                    )\n                )\n                return switches\n\n            aux_nodes: list[VariableNode] = [\n                VariableNode(name=f\"{left_node.name}_{idx}\", attribute=NodeAttribute.ZERO_OR_ONE)\n                for idx, left_node in enumerate(left_nodes)\n            ]\n            for i in range(num_variables // 2):\n                switches.append(\n                    Switch(\n                        left_nodes=frozenset([\n                            left_nodes[i].name,\n                            left_nodes[i + ceil(num_variables / 2)].name,\n                        ]),\n                        right_nodes=frozenset(\n                            [\n                                aux_nodes[i].name,\n                                aux_nodes[i + ceil(num_variables / 2)].name,\n                            ],\n                        ),\n                    )\n                )\n            # For nodes where no swap occurred, assign directly to aux_nodes\n            if num_variables % 2 == 1:\n                aux_nodes[num_variables // 2] = left_nodes[num_variables // 2]\n\n            switches.extend(\n                cls._generate_original_network(\n                    left_nodes=aux_nodes[: ceil(num_variables / 2)],\n                    right_nodes=node_dict[NodeAttribute.ALWAYS_ONE][\n                        : ceil(len(node_dict[NodeAttribute.ALWAYS_ONE]) / 2)\n                    ]\n                    + node_dict[NodeAttribute.ALWAYS_ZERO][\n                        : ceil(num_variables / 2) - ceil(len(node_dict[NodeAttribute.ALWAYS_ONE]) / 2)\n                    ],\n                    threshold=threshold,\n                )\n            )\n            switches.extend(\n                cls._generate_original_network(\n                    left_nodes=aux_nodes[ceil(num_variables / 2) :],\n                    right_nodes=node_dict[NodeAttribute.ALWAYS_ONE][\n                        ceil(len(node_dict[NodeAttribute.ALWAYS_ONE]) / 2) :\n                    ]\n                    + node_dict[NodeAttribute.ALWAYS_ZERO][\n                        ceil(num_variables / 2) - ceil(len(node_dict[NodeAttribute.ALWAYS_ONE]) / 2) :\n                    ],\n                    threshold=threshold,\n                )\n            )\n            return switches\n</code></pre>"},{"location":"modules/#sparse_qubo.networks.oddeven_merge_sort_network","title":"<code>sparse_qubo.networks.oddeven_merge_sort_network</code>","text":"<p>Implementation of Odd-even merge sort network: Batcher's algorithm.</p>"},{"location":"modules/#sparse_qubo.networks.oddeven_merge_sort_network.OddEvenMergeSortNetwork","title":"<code>OddEvenMergeSortNetwork</code>","text":"<p>               Bases: <code>ISwitchingNetwork</code></p> <p>Odd-even merge sort (Batcher) network; requires power-of-2 variable count.</p> Source code in <code>src/sparse_qubo/networks/oddeven_merge_sort_network.py</code> <pre><code>class OddEvenMergeSortNetwork(ISwitchingNetwork):\n    \"\"\"Odd-even merge sort (Batcher) network; requires power-of-2 variable count.\"\"\"\n\n    @classmethod\n    def _generate_original_network(\n        cls,\n        left_nodes: list[VariableNode],\n        right_nodes: list[VariableNode],\n        threshold: int | None = None,\n        reverse: bool = True,\n    ) -&gt; list[Switch]:\n        \"\"\"Return the list of Switch elements for the odd-even merge sort network.\"\"\"\n        left_names = [node.name for node in left_nodes]\n        right_names = [node.name for node in right_nodes]\n        if len(left_names) != len(right_names):\n            raise ValueError(\"left_nodes and right_nodes must have the same length\")\n        N: int = len(left_names)\n        n: int = round(log2(N))\n        if 2**n != N:\n            raise ValueError(\"N must be a power of 2\")\n\n        if not reverse:\n            left_names, right_names = right_names, left_names\n\n        progress: list[int] = [0] * N\n        temp_result_switches: list[Switch] = []\n        # m is called in the order (0, 1, 2, 3), (0, 1, 2), (0, 1), (0)\n        for m_max in range(1, n + 1)[::-1]:\n            M_max: int = 2**m_max\n            for i_base in range(0, N, M_max):\n                for m in range(m_max):\n                    M: int = 2**m\n                    i_start: int = i_base if m &lt; m_max - 1 else i_base - M\n                    i_end: int = i_base + M_max - M\n                    for i in range(i_start, i_end):\n                        if (i - i_start) // M % 2 == 1:\n                            temp_result_switches.append(\n                                Switch(\n                                    left_nodes=frozenset([\n                                        f\"{i}_{progress[i]}\",\n                                        f\"{i + M}_{progress[i + M]}\",\n                                    ]),\n                                    right_nodes=frozenset([\n                                        f\"{i}_{progress[i] + 1}\",\n                                        f\"{i + M}_{progress[i + M] + 1}\",\n                                    ]),\n                                )\n                            )\n                            progress[i] += 1\n                            progress[i + M] += 1\n        temp_name_to_result_name: dict[str, str] = {}\n        for i in range(N):\n            for j in range(progress[i] + 1):\n                if j == 0:\n                    temp_name_to_result_name[f\"{i}_{j}\"] = left_names[i]\n                elif j == progress[i]:\n                    temp_name_to_result_name[f\"{i}_{j}\"] = right_names[i]\n                else:\n                    temp_name_to_result_name[f\"{i}_{j}\"] = f\"{left_names[i]}_{j - 1}_{right_names[i]}\"\n        if reverse:\n            return [\n                Switch(\n                    left_nodes=frozenset([temp_name_to_result_name[left_node] for left_node in switch.left_nodes]),\n                    right_nodes=frozenset([temp_name_to_result_name[right_node] for right_node in switch.right_nodes]),\n                )\n                for switch in temp_result_switches\n            ]\n        else:\n            res = [\n                Switch(\n                    left_nodes=frozenset([temp_name_to_result_name[left_node] for left_node in switch.right_nodes]),\n                    right_nodes=frozenset([temp_name_to_result_name[right_node] for right_node in switch.left_nodes]),\n                )\n                for switch in temp_result_switches\n            ]\n            return res[::-1]\n</code></pre>"},{"location":"modules/#d-wave-integration","title":"D-Wave integration","text":"<p>Public entry point: <code>sparse_qubo.create_constraint_dwave</code>. Implementation module:</p>"},{"location":"modules/#sparse_qubo.dwave.constraint","title":"<code>sparse_qubo.dwave.constraint</code>","text":"<p>D-Wave/dimod integration: build dimod BQMs from constraint types and network types.</p> <p>Use create_constraint_dwave (from sparse_qubo) or constraint() from this module to obtain a BinaryQuadraticModel for use with D-Wave samplers or dimod.</p>"},{"location":"modules/#sparse_qubo.dwave.constraint.constraint","title":"<code>constraint(variables, constraint_type, network_type=NetworkType.DIVIDE_AND_CONQUER, c1=None, c2=None, threshold=None)</code>","text":"<p>Build a dimod BQM for the given constraint using the specified network type (or NAIVE).</p> Source code in <code>src/sparse_qubo/dwave/constraint.py</code> <pre><code>def constraint(\n    variables: dimod.variables.Variables,\n    constraint_type: ConstraintType,\n    network_type: NetworkType = NetworkType.DIVIDE_AND_CONQUER,\n    c1: int | None = None,\n    c2: int | None = None,\n    threshold: int | None = None,\n) -&gt; dimod.BinaryQuadraticModel:\n    \"\"\"Build a dimod BQM for the given constraint using the specified network type (or NAIVE).\"\"\"\n    if network_type == NetworkType.NAIVE:\n        bqm = naive_constraint(variables, constraint_type, c1, c2)\n        return bqm\n\n    variable_names = [str(v) for v in variables]\n    qubo = get_constraint_qubo(variable_names, constraint_type, network_type, c1, c2, threshold)\n    bqm = dimod.BinaryQuadraticModel(\n        qubo.linear,\n        qubo.quadratic,\n        qubo.constant,\n        dimod.BINARY,\n    )\n    return bqm\n</code></pre>"},{"location":"modules/#sparse_qubo.dwave.constraint.naive_constraint","title":"<code>naive_constraint(variables, constraint_type, c1=None, c2=None)</code>","text":"<p>Encode the constraint as a single linear equality/inequality (no switching network).</p> Source code in <code>src/sparse_qubo/dwave/constraint.py</code> <pre><code>def naive_constraint(\n    variables: dimod.variables.Variables,\n    constraint_type: ConstraintType,\n    c1: int | None = None,\n    c2: int | None = None,\n) -&gt; dimod.BinaryQuadraticModel:\n    \"\"\"Encode the constraint as a single linear equality/inequality (no switching network).\"\"\"\n    size = len(variables)\n    terms = [(str(v), 1) for v in variables]\n    bqm = dimod.BinaryQuadraticModel(dimod.BINARY)\n    lagrange_multiplier = 1\n    match constraint_type:\n        case ConstraintType.ONE_HOT:\n            bqm.add_linear_equality_constraint(terms, lagrange_multiplier, -1)\n        case ConstraintType.EQUAL_TO:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            bqm.add_linear_equality_constraint(terms, lagrange_multiplier, -c1)\n        case ConstraintType.LESS_EQUAL:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            bqm.add_linear_inequality_constraint(terms, lagrange_multiplier, label=\"s\", ub=c1)\n        case ConstraintType.GREATER_EQUAL:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            bqm.add_linear_inequality_constraint(terms, lagrange_multiplier, label=\"s\", lb=c1, ub=size)\n        case ConstraintType.CLAMP:\n            if not (c1 is not None and c2 is not None and 0 &lt;= c1 &lt;= c2 &lt;= size):\n                raise ValueError(\"c1 and c2 must be between 0 and size\")\n            bqm.add_linear_inequality_constraint(terms, lagrange_multiplier, label=\"s\", lb=c1, ub=c2)\n        case _:\n            raise NotImplementedError\n\n    return bqm\n</code></pre>"},{"location":"modules/#fixstars-amplify-integration","title":"Fixstars Amplify integration","text":"<p>Public entry point: <code>sparse_qubo.create_constraint_amplify</code>. Implementation module:</p>"},{"location":"modules/#sparse_qubo.fixstars_amplify.constraint","title":"<code>sparse_qubo.fixstars_amplify.constraint</code>","text":"<p>Fixstars Amplify integration: build Amplify models from constraint types and network types.</p> <p>Use create_constraint_amplify (from sparse_qubo) or constraint() from this module to obtain an amplify.Model for use with Amplify solvers.</p>"},{"location":"modules/#sparse_qubo.fixstars_amplify.constraint.constraint","title":"<code>constraint(variables, constraint_type, network_type=NetworkType.DIVIDE_AND_CONQUER, c1=None, c2=None, threshold=None)</code>","text":"<p>Build an Amplify model for the given constraint using the specified network type (or NAIVE).</p> Source code in <code>src/sparse_qubo/fixstars_amplify/constraint.py</code> <pre><code>def constraint(\n    variables: list[amplify.Variable],\n    constraint_type: ConstraintType,\n    network_type: NetworkType = NetworkType.DIVIDE_AND_CONQUER,\n    c1: int | None = None,\n    c2: int | None = None,\n    threshold: int | None = None,\n) -&gt; amplify.Model:\n    \"\"\"Build an Amplify model for the given constraint using the specified network type (or NAIVE).\"\"\"\n    if network_type == NetworkType.NAIVE:\n        model = naive_constraint(variables, constraint_type, c1, c2)\n        return model\n\n    variable_names = [v.name for v in variables]\n    qubo = get_constraint_qubo(variable_names, constraint_type, network_type, c1, c2, threshold)\n    model = generate_amplify_model(variables, qubo)\n    return model\n</code></pre>"},{"location":"modules/#sparse_qubo.fixstars_amplify.constraint.generate_amplify_model","title":"<code>generate_amplify_model(variables, qubo)</code>","text":"<p>Build an Amplify model from a list of Amplify variables and a QUBO (linear + quadratic + constant).</p> Source code in <code>src/sparse_qubo/fixstars_amplify/constraint.py</code> <pre><code>def generate_amplify_model(variables: list[amplify.Variable], qubo: QUBO) -&gt; amplify.Model:\n    \"\"\"Build an Amplify model from a list of Amplify variables and a QUBO (linear + quadratic + constant).\"\"\"\n    poly_map = {v.name: amplify.Poly(v) for v in variables}\n    objectives = amplify.Poly(0)\n\n    for (v1, v2), coef in qubo.quadratic.items():\n        objectives += coef * poly_map[v1] * poly_map[v2]\n    for v, coef in qubo.linear.items():\n        objectives += coef * poly_map[v]\n    objectives += qubo.constant\n\n    return amplify.Model(objectives)\n</code></pre>"},{"location":"modules/#sparse_qubo.fixstars_amplify.constraint.naive_constraint","title":"<code>naive_constraint(variables, constraint_type, c1=None, c2=None)</code>","text":"<p>Encode the constraint using Amplify's built-in one_hot/equal_to/less_equal/etc. (no switching network).</p> Source code in <code>src/sparse_qubo/fixstars_amplify/constraint.py</code> <pre><code>def naive_constraint(\n    variables: list[amplify.Variable],\n    constraint_type: ConstraintType,\n    c1: int | None = None,\n    c2: int | None = None,\n) -&gt; amplify.Model:\n    \"\"\"Encode the constraint using Amplify's built-in one_hot/equal_to/less_equal/etc. (no switching network).\"\"\"\n    size = len(variables)\n    sum_poly: amplify.Poly = sum([amplify.Poly(v) for v in variables], amplify.Poly(0))\n    match constraint_type:\n        case ConstraintType.ONE_HOT:\n            constraint = amplify.one_hot(sum_poly)\n        case ConstraintType.EQUAL_TO:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            constraint = amplify.equal_to(sum_poly, c1)\n        case ConstraintType.LESS_EQUAL:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            constraint = amplify.less_equal(sum_poly, c1)\n        case ConstraintType.GREATER_EQUAL:\n            if not (c1 is not None and 0 &lt;= c1 &lt;= size):\n                raise ValueError(\"c1 must be between 0 and size\")\n            constraint = amplify.greater_equal(sum_poly, c1)\n        case ConstraintType.CLAMP:\n            if not (c1 is not None and c2 is not None and 0 &lt;= c1 &lt;= c2 &lt;= size):\n                raise ValueError(\"c1 and c2 must be between 0 and size\")\n            constraint = amplify.clamp(sum_poly, (c1, c2))\n        case _:\n            raise NotImplementedError\n\n    return amplify.Model(constraint)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#constraint-prefix-counter","title":"Constraint prefix counter","text":"<p>When you build constraint QUBOs with <code>get_constraint_qubo</code> or high-level APIs like <code>sparse_qubo.create_constraint_dwave()</code> and <code>sparse_qubo.create_constraint_amplify()</code>, the library adds auxiliary variables (e.g. <code>L0</code>, <code>R0</code>, and variables introduced by the switching network built from Switch elements). See Getting Started for the Switch/switching-network overview. To avoid name collisions when merging multiple constraint QUBOs into one BQM, each constraint\u2019s auxiliary variables are given a unique prefix (e.g. <code>C0_L0</code>, <code>C1_L0</code>).</p>"},{"location":"usage/#how-the-counter-behaves","title":"How the counter behaves","text":"<ul> <li>When it increments: Each time you create a constraint (with the default <code>var_prefix=None</code>), the internal counter is used as the prefix (<code>C0</code>, <code>C1</code>, <code>C2</code>, \u2026) and then incremented.</li> <li>When it resets: The counter is not reset automatically. It is reset only in these cases:</li> <li>Process start: Restarting Python (e.g. re-running a script or restarting a Jupyter kernel) reloads the module, so the counter starts at 0 again.</li> <li>Explicit reset: You call <code>reset_constraint_prefix_counter()</code> from <code>sparse_qubo.core.constraint</code>.</li> </ul>"},{"location":"usage/#practical-impact","title":"Practical impact","text":"<ul> <li>Same process, multiple constraints: If you create several constraints and add their QUBOs/BQMs together, each gets a different prefix (<code>C0</code>, <code>C1</code>, \u2026), so variable names do not collide.</li> <li>Re-running a script or notebook (same kernel): The counter keeps increasing. For example, the second run might use <code>C3</code>, <code>C4</code>, <code>C5</code> instead of <code>C0</code>, <code>C1</code>, <code>C2</code>. Names stay unique; only the numeric part changes.</li> <li>Starting a new model in the same process: If you want the \u201cfirst\u201d constraint of a new model to use <code>C0</code> again, call <code>reset_constraint_prefix_counter()</code> before building the new model. This is optional and mainly useful for reproducible variable names or tests.</li> </ul>"}]}